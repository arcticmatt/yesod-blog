-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Pure-Haskell utilities for dealing with XML with the conduit package.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/xml-conduit</a>.
@package xml-conduit
@version 1.4.0.4


-- | <tt>Enumeratee</tt>s to render XML <a>Event</a>s. Unlike
--   libxml-enumerator and expat-enumerator, this module does not provide
--   IO and ST variants, since the underlying rendering operations are pure
--   functions.
module Text.XML.Stream.Render

-- | Render a stream of <a>Event</a>s into a stream of <a>Builder</a>s.
--   Builders are from the blaze-builder package, and allow the create of
--   optimally sized <a>ByteString</a>s with minimal buffer copying.
renderBuilder :: Monad m => RenderSettings -> Conduit Event m Builder

-- | Same as <a>renderBuilder</a> but allows you to flush XML stream to
--   ensure that all events at needed point are rendered.
renderBuilderFlush :: Monad m => RenderSettings -> Conduit (Flush Event) m (Flush Builder)

-- | Render a stream of <a>Event</a>s into a stream of <a>ByteString</a>s.
--   This function wraps around <a>renderBuilder</a> and
--   <a>builderToByteString</a>, so it produces optimally sized
--   <a>ByteString</a>s with minimal buffer copying.
--   
--   The output is UTF8 encoded. renderBytes :: Monad m =&gt;
--   RenderSettings -&gt; Conduit Event m ByteString
renderBytes :: (PrimMonad base, MonadBase base m) => RenderSettings -> ConduitM Event ByteString m ()

-- | Render a stream of <a>Event</a>s into a stream of <a>Text</a>s. This
--   function wraps around <a>renderBuilder</a>, <a>builderToByteString</a>
--   and <a>renderBytes</a>, so it produces optimally sized <a>Text</a>s
--   with minimal buffer copying.
renderText :: (MonadThrow m, MonadBase base m, PrimMonad base) => RenderSettings -> ConduitM Event Text m ()

-- | Convert a stream of <a>Event</a>s into a prettified one, adding extra
--   whitespace. Note that this can change the meaning of your XML.
prettify :: Monad m => Conduit (Flush Event) m (Flush Event)
data RenderSettings

-- | The default value for this type.
def :: Default a => a
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]

-- | Specify how to turn the unordered attributes used by the
--   <a>Text.XML</a> module into an ordered list.
rsAttrOrder :: RenderSettings -> Name -> Map Name Text -> [(Name, Text)]

-- | Determines if for a given text content the renderer should use a CDATA
--   node.
--   
--   Default: <tt>False</tt>
rsUseCDATA :: RenderSettings -> Content -> Bool

-- | Convenience function to create an ordering function suitable for use
--   as the value of <a>rsAttrOrder</a>. The ordering function is created
--   from an explicit ordering of the attributes, specified as a list of
--   tuples, as follows: In each tuple, the first component is the
--   <a>Name</a> of an element, and the second component is a list of
--   attributes names. When the given element is rendered, the attributes
--   listed, when present, appear first in the given order, followed by any
--   other attributes in arbitrary order. If an element does not appear,
--   all of its attributes are rendered in arbitrary order.
orderAttrs :: [(Name, [Name])] -> Name -> Map Name Text -> [(Name, Text)]

-- | Generate a complete XML <tt>Element</tt>.
tag :: (Monad m) => Name -> Attributes -> Source m Event -> Source m Event

-- | Generate a textual <a>EventContent</a>.
content :: (Monad m) => Text -> Source m Event

-- | A list of attributes.
data Attributes

-- | Generate a single attribute.
attr :: Name -> Text -> Attributes

-- | Helper function that generates a valid attribute if input isn't
--   <a>Nothing</a>, or <a>mempty</a> otherwise.
optionalAttr :: Name -> Maybe Text -> Attributes
instance Data.Default.Class.Default Text.XML.Stream.Render.RenderSettings
instance GHC.Base.Monoid Text.XML.Stream.Render.Attributes


-- | This module provides both a native Haskell solution for parsing XML
--   documents into a stream of events, and a set of parser combinators for
--   dealing with a stream of events.
--   
--   As a simple example, if you have the following XML file:
--   
--   <pre>
--   &lt;?xml version="1.0" encoding="utf-8"?&gt;
--   &lt;people&gt;
--       &lt;person age="25"&gt;Michael&lt;/person&gt;
--       &lt;person age="2"&gt;Eliezer&lt;/person&gt;
--   &lt;/people&gt;
--   </pre>
--   
--   Then this code:
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Control.Monad.Trans.Resource
--   import Data.Conduit (($$))
--   import Data.Text (Text, unpack)
--   import Text.XML.Stream.Parse
--   
--   data Person = Person Int Text
--       deriving Show
--   
--   parsePerson = tagName "person" (requireAttr "age") $ \age -&gt; do
--       name &lt;- content
--       return $ Person (read $ unpack age) name
--   
--   parsePeople = tagNoAttr "people" $ many parsePerson
--   
--   main = do
--       people &lt;- runResourceT $
--               parseFile def "people.xml" $$ force "people required" parsePeople
--       print people
--   </pre>
--   
--   will produce:
--   
--   <pre>
--   [Person {age = 25, name = "Michael"},Person {age = 2, name = "Eliezer"}]
--   </pre>
--   
--   This module also supports streaming results using <a>yield</a>. This
--   allows parser results to be processed using conduits while a
--   particular parser (e.g. <a>many</a>) is still running. Without using
--   streaming results, you have to wait until the parser finished before
--   you can process the result list. Large XML files might be easier to
--   process by using streaming results. See
--   <a>http://stackoverflow.com/q/21367423/2597135</a> for a related
--   discussion.
--   
--   <pre>
--   {-# LANGUAGE OverloadedStrings #-}
--   import Control.Monad.Trans.Resource
--   import Data.Conduit
--   import Data.Text (Text, unpack)
--   import Text.XML.Stream.Parse
--   import Text.XML (Name)
--   import Control.Monad.Trans.Class (lift)
--   import Control.Monad (void)
--   import qualified Data.Conduit.List as CL
--   
--   data Person = Person Int Text deriving Show
--   
--   parsePerson = tagName "person" (requireAttr "age") $ \age -&gt; do
--       name &lt;- content
--       return $ Person (read $ unpack age) name
--   
--   parsePeople = void $ tagNoAttr "people" $ manyYield parsePerson
--   
--   main = runResourceT $
--       parseFile def "people.xml" $$ parsePeople =$ CL.mapM_ (lift . print)
--   </pre>
--   
--   Previous versions of this module contained a number of more
--   sophisticated functions written by Aristid Breitkreuz and Dmitry
--   Olshansky. To keep this package simpler, those functions are being
--   moved to a separate package. This note will be updated with the name
--   of the package(s) when available.
module Text.XML.Stream.Parse

-- | Parses a byte stream into <a>Event</a>s. This function is implemented
--   fully in Haskell using attoparsec-text for parsing. The produced error
--   messages do not give line/column information, so you may prefer to
--   stick with the parser provided by libxml-enumerator. However, this has
--   the advantage of not relying on any C libraries.
--   
--   This relies on <a>detectUtf</a> to determine character encoding, and
--   <a>parseText'</a> to do the actual parsing.
parseBytes :: MonadThrow m => ParseSettings -> Conduit ByteString m Event
parseBytesPos :: MonadThrow m => ParseSettings -> Conduit ByteString m EventPos

-- | Parses a character stream into <a>Event</a>s. This function is
--   implemented fully in Haskell using attoparsec-text for parsing. The
--   produced error messages do not give line/column information, so you
--   may prefer to stick with the parser provided by libxml-enumerator.
--   However, this has the advantage of not relying on any C libraries.
--   
--   Since 1.2.4
parseText' :: MonadThrow m => ParseSettings -> Conduit Text m Event

-- | <i>Deprecated: Please use <a>parseText'</a> or
--   <a>parseTextPos</a>.</i>
parseText :: MonadThrow m => ParseSettings -> Conduit Text m EventPos

-- | Same as <a>parseText'</a>, but includes the position of each event.
--   
--   Since 1.2.4
parseTextPos :: MonadThrow m => ParseSettings -> Conduit Text m EventPos

-- | Automatically determine which UTF variant is being used. This function
--   first checks for BOMs, removing them as necessary, and then check for
--   the equivalent of &lt;?xml for each of UTF-8, UTF-16LE<i>BE, and
--   UTF-32LE</i>BE. It defaults to assuming UTF-8.
detectUtf :: MonadThrow m => Conduit ByteString m Text

-- | A helper function which reads a file from disk using
--   <tt>enumFile</tt>, detects character encoding using <a>detectUtf</a>,
--   parses the XML using <a>parseBytes</a>, and then hands off control to
--   your supplied parser.
parseFile :: MonadResource m => ParseSettings -> FilePath -> Producer m Event

-- | Parse an event stream from a lazy <a>ByteString</a>.
parseLBS :: MonadThrow m => ParseSettings -> ByteString -> Producer m Event
data ParseSettings

-- | The default value for this type.
def :: Default a => a
type DecodeEntities = Text -> Content
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool

-- | Default implementation of <a>DecodeEntities</a>: handles numeric
--   entities and the five standard character entities (lt, gt, amp, quot,
--   apos).
decodeXmlEntities :: DecodeEntities

-- | HTML4-compliant entity decoder. Handles numerics, the five standard
--   character entities, and the additional 248 entities defined by HTML 4
--   and XHTML 1.
--   
--   Note that HTML 5 introduces a drastically larger number of entities,
--   and this code does not recognize most of them.
decodeHtmlEntities :: DecodeEntities

-- | The most generic way to parse a tag. It takes a predicate for checking
--   if this is the correct tag name, an <a>AttrParser</a> for handling
--   attributes, and then a parser for dealing with content.
--   
--   <tt>Events</tt> are consumed if and only if the predicate holds.
--   
--   This function automatically absorbs its balancing closing tag, and
--   will throw an exception if not all of the attributes or child elements
--   are consumed. If you want to allow extra attributes, see
--   <a>ignoreAttrs</a>.
--   
--   This function automatically ignores comments, instructions and
--   whitespace.

-- | <i>Deprecated: The signature of this function will change in next
--   release.</i>
tag :: MonadThrow m => (Name -> Maybe a) -> (a -> AttrParser b) -> (b -> ConduitM Event o m c) -> ConduitM Event o m (Maybe c)

-- | A simplified version of <a>tag</a> which matches against boolean
--   predicates.

-- | <i>Deprecated: This function will be removed in next release.</i>
tagPredicate :: MonadThrow m => (Name -> Bool) -> AttrParser a -> (a -> ConduitM Event o m b) -> ConduitM Event o m (Maybe b)

-- | A simplified version of <a>tag</a> which matches for specific tag
--   names instead of taking a predicate function. This is often
--   sufficient, and when combined with OverloadedStrings and the IsString
--   instance of <a>Name</a>, can prove to be very concise. . Note that
--   <tt>Name</tt> is namespace sensitive. When using the <tt>IsString</tt>
--   instance of name, use &gt; "{http:/<i>a</i>b}c" :: Name to match the
--   tag <tt>c</tt> in the XML namespace <tt><a>http://a/b</a></tt>

-- | <i>Deprecated: This function will be removed in next release.</i>
tagName :: MonadThrow m => Name -> AttrParser a -> (a -> ConduitM Event o m b) -> ConduitM Event o m (Maybe b)

-- | A further simplified tag parser, which requires that no attributes
--   exist.

-- | <i>Deprecated: The signature of this function will change in next
--   release.</i>
tagNoAttr :: MonadThrow m => Name -> ConduitM Event o m a -> ConduitM Event o m (Maybe a)

-- | A further simplified tag parser, which ignores all attributes, if any
--   exist

-- | <i>Deprecated: The signature of this function will change in next
--   release.</i>
tagIgnoreAttrs :: MonadThrow m => Name -> ConduitM Event o m a -> ConduitM Event o m (Maybe a)

-- | A further simplified tag parser, which ignores all attributes, if any
--   exist

-- | <i>Deprecated: This function will be removed in next release.</i>
tagPredicateIgnoreAttrs :: MonadThrow m => (Name -> Bool) -> ConduitM Event o m a -> ConduitM Event o m (Maybe a)

-- | Grabs the next piece of content. If none if available, returns
--   <a>empty</a>. This is simply a wrapper around <a>contentMaybe</a>.
content :: MonadThrow m => Consumer Event m Text

-- | Grabs the next piece of content if available. This function skips over
--   any comments and instructions and concatenates all content until the
--   next start or end tag.
contentMaybe :: MonadThrow m => Consumer Event m (Maybe Text)

-- | Ignore an empty tag and all of its attributes by predicate. This does
--   not ignore the tag recursively (i.e. it assumes there are no child
--   elements). This functions returns <a>Just</a> if the tag matched.

-- | <i>Deprecated: The signature of this function will change in next
--   release.</i>
ignoreTag :: MonadThrow m => (Name -> Bool) -> ConduitM Event o m (Maybe ())

-- | Like <a>ignoreTag</a>, but matches an exact name

-- | <i>Deprecated: This function will be removed in next release.</i>
ignoreTagName :: MonadThrow m => Name -> ConduitM Event o m (Maybe ())

-- | Like <a>ignoreTagName</a>, but matches any name from a list of names.

-- | <i>Deprecated: This function will be removed in next release.</i>
ignoreAnyTagName :: MonadThrow m => [Name] -> ConduitM Event o m (Maybe ())

-- | Like <a>ignoreTag</a>, but matches all tag name.
--   
--   <pre>
--   ignoreAllTags = ignoreTag (const True)
--   </pre>

-- | <i>Deprecated: This function will be removed in next release.</i>
ignoreAllTags :: MonadThrow m => ConduitM Event o m (Maybe ())

-- | Ignore an empty tag, its attributes and its children subtree
--   recursively. Both content and text events are ignored. This functions
--   returns <a>Just</a> if the tag matched.

-- | <i>Deprecated: The signature of this function will change in next
--   release.</i>
ignoreTree :: MonadThrow m => (Name -> Bool) -> ConduitM Event o m (Maybe ())

-- | Like <a>ignoreTagName</a>, but also ignores non-empty tabs

-- | <i>Deprecated: This function will be removed in next release.</i>
ignoreTreeName :: MonadThrow m => Name -> ConduitM Event o m (Maybe ())

-- | Like <a>ignoreTagName</a>, but matches any name from a list of names.

-- | <i>Deprecated: This function will be removed in next release.</i>
ignoreAnyTreeName :: MonadThrow m => [Name] -> ConduitM Event o m (Maybe ())

-- | Like <a>ignoreAllTags</a>, but ignores entire subtrees.
--   
--   <pre>
--   ignoreAllTrees = ignoreTree (const True)
--   </pre>

-- | <i>Deprecated: This function will be removed in next release.</i>
ignoreAllTrees :: MonadThrow m => ConduitM Event o m (Maybe ())

-- | Like <a>ignoreAllTrees</a>, but also ignores all content events

-- | <i>Deprecated: This function will be renamed into
--   <tt>ignoreAnyTreeContent</tt> in next release.</i>
ignoreAllTreesContent :: MonadThrow m => ConduitM Event o m (Maybe ())

-- | A monad for parsing attributes. By default, it requires you to deal
--   with all attributes present on an element, and will throw an exception
--   if there are unhandled attributes. Use the <a>requireAttr</a>,
--   <a>attr</a> et al functions for handling an attribute, and
--   <a>ignoreAttrs</a> if you would like to skip the rest of the
--   attributes on an element.
--   
--   <a>Alternative</a> instance behaves like <tt>First</tt> monoid: it
--   chooses first parser which doesn't fail.
data AttrParser a

-- | Return the value for an attribute if present.
attr :: Name -> AttrParser (Maybe Text)

-- | Shortcut composition of <a>force</a> and <a>attr</a>.
requireAttr :: Name -> AttrParser Text

-- | <i>Deprecated: Please use <a>attr</a>.</i>
optionalAttr :: Name -> AttrParser (Maybe Text)
requireAttrRaw :: String -> ((Name, [Content]) -> Maybe b) -> AttrParser b
optionalAttrRaw :: ((Name, [Content]) -> Maybe b) -> AttrParser (Maybe b)

-- | Skip the remaining attributes on an element. Since this will clear the
--   list of attributes, you must call this <i>after</i> any calls to
--   <a>requireAttr</a>, <a>optionalAttr</a>, etc.
ignoreAttrs :: AttrParser ()

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <tt>Just</tt>), this function returns
--   <a>Nothing</a>.
--   
--   <pre>
--   orE a b = choose [a, b]
--   </pre>
orE :: Monad m => Consumer Event m (Maybe a) -> Consumer Event m (Maybe a) -> Consumer Event m (Maybe a)

-- | Get the value of the first parser which returns <a>Just</a>. If no
--   parsers succeed (i.e., return <a>Just</a>), this function returns
--   <a>Nothing</a>.
choose :: Monad m => [ConduitM Event o m (Maybe a)] -> ConduitM Event o m (Maybe a)

-- | Keep parsing elements as long as the parser returns <a>Just</a>.
many :: Monad m => Consumer Event m (Maybe a) -> Consumer Event m [a]

-- | Keep parsing elements as long as the parser returns <a>Just</a> or the
--   ignore parser returns <a>Just</a>.
manyIgnore :: Monad m => Consumer Event m (Maybe a) -> Consumer Event m (Maybe ()) -> Consumer Event m [a]

-- | Like <tt>many</tt>, but any tags and content the consumer doesn't
--   match on are silently ignored.
many' :: MonadThrow m => Consumer Event m (Maybe a) -> Consumer Event m [a]

-- | Force an optional parser into a required parser. All of the <a>tag</a>
--   functions, <a>attr</a>, <a>choose</a> and <a>many</a> deal with
--   <a>Maybe</a> parsers. Use this when you want to finally force
--   something to happen.
force :: MonadThrow m => String -> m (Maybe a) -> m a

-- | Like <a>many</a>, but uses <a>yield</a> so the result list can be
--   streamed to downstream conduits without waiting for <a>manyYield</a>
--   to finish
manyYield :: Monad m => ConduitM a b m (Maybe b) -> Conduit a m b

-- | Like <tt>manyIgnore</tt>, but uses <a>yield</a> so the result list can
--   be streamed to downstream conduits without waiting for
--   <a>manyYield</a> to finish
manyIgnoreYield :: MonadThrow m => ConduitM Event b m (Maybe b) -> Consumer Event m (Maybe ()) -> Conduit Event m b

-- | Like <tt>many'</tt>, but uses <a>yield</a> so the result list can be
--   streamed to downstream conduits without waiting for <a>manyYield</a>
--   to finish
manyYield' :: MonadThrow m => ConduitM Event b m (Maybe b) -> Conduit Event m b

-- | Like <a>ignoreAllTreesContent</a>, but stream the corresponding
--   <a>Event</a>s rather than ignoring them. Incomplete elements (without
--   a closing-tag) will trigger an <a>XmlException</a>.
--   
--   <pre>
--   &gt;&gt;&gt; runResourceT $ parseLBS def "text&lt;a&gt;&lt;/a&gt;" $$ takeAllTreesContent =$= consume
--   Just [ EventContent (ContentText "text"), EventBeginElement "a" [], EventEndElement "a"]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runResourceT $ parseLBS def "&lt;/a&gt;&lt;b&gt;&lt;/b&gt;" $$ takeAllTreesContent =$= consume
--   Just [ ]
--   </pre>
--   
--   <pre>
--   &gt;&gt;&gt; runResourceT $ parseLBS def "&lt;b&gt;&lt;c&gt;&lt;/c&gt;&lt;/b&gt;&lt;/a&gt;text" $$ takeAllTreesContent =$= consume
--   Just [ EventBeginElement "b" [], EventBeginElement "c" [], EventEndElement "c", EventEndElement "b" ]
--   </pre>
--   
--   Since 1.4.0

-- | <i>Deprecated: This function will be removed in next release.</i>
takeAllTreesContent :: MonadThrow m => Conduit Event m Event
data XmlException
XmlException :: String -> Maybe Event -> XmlException
[xmlErrorMessage] :: XmlException -> String
[xmlBadInput] :: XmlException -> Maybe Event
InvalidEndElement :: Name -> (Maybe Event) -> XmlException
InvalidEntity :: String -> (Maybe Event) -> XmlException
MissingAttribute :: String -> XmlException
UnparsedAttributes :: [(Name, [Content])] -> XmlException
data PositionRange :: *
type EventPos = (Maybe PositionRange, Event)
instance GHC.Show.Show Text.XML.Stream.Parse.XmlException
instance Data.Default.Class.Default Text.XML.Stream.Parse.ParseSettings
instance GHC.Exception.Exception Text.XML.Stream.Parse.XmlException
instance GHC.Base.Monad Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Functor Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Applicative Text.XML.Stream.Parse.AttrParser
instance GHC.Base.Alternative Text.XML.Stream.Parse.AttrParser
instance Control.Monad.Catch.MonadThrow Text.XML.Stream.Parse.AttrParser


-- | DOM-based XML parsing and rendering.
--   
--   In this module, attribute values and content nodes can contain either
--   raw text or entities. In most cases, these can be fully resolved at
--   parsing. If that is the case for your documents, the <a>Text.XML</a>
--   module provides simplified datatypes that only contain raw text.
module Text.XML.Unresolved
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
readFile :: ParseSettings -> FilePath -> IO Document
renderLBS :: RenderSettings -> Document -> ByteString
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
sinkTextDoc :: MonadThrow m => ParseSettings -> Consumer Text m Document
sinkDoc :: MonadThrow m => ParseSettings -> Consumer ByteString m Document

-- | Render a document into events.
toEvents :: Document -> [Event]

-- | Render a document element into events.
elementToEvents :: Element -> [Event]

-- | Parse a document from a stream of events.
fromEvents :: MonadThrow m => Consumer EventPos m Document

-- | Try to parse a document element (as defined in XML) from a stream of
--   events.
elementFromEvents :: MonadThrow m => Consumer EventPos m (Maybe Element)
renderBuilder :: Monad m => RenderSettings -> Document -> Producer m Builder
renderBytes :: (MonadBase base m, PrimMonad base) => RenderSettings -> Document -> ConduitM a ByteString m ()
renderText :: (PrimMonad base, MonadBase base m, MonadThrow m) => RenderSettings -> Document -> ConduitM a Text m ()
data InvalidEventStream
ContentAfterRoot :: EventPos -> InvalidEventStream
MissingRootElement :: InvalidEventStream
InvalidInlineDoctype :: EventPos -> InvalidEventStream
MissingEndElement :: Name -> (Maybe EventPos) -> InvalidEventStream
UnterminatedInlineDoctype :: InvalidEventStream

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool
data RenderSettings
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]
instance GHC.Exception.Exception Text.XML.Unresolved.InvalidEventStream
instance GHC.Show.Show Text.XML.Unresolved.InvalidEventStream


-- | Generalized cursors to be applied to different nodes.
module Text.XML.Cursor.Generic

-- | A cursor: contains an XML <tt>Node</tt> and pointers to its children,
--   ancestors and siblings.
data Cursor node
type Axis node = Cursor node -> [Cursor node]
toCursor :: (node -> [node]) -> node -> Cursor node

-- | The current node.
node :: Cursor node -> node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> (Cursor node -> [b])
infixr 1 &|

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])
infixr 1 &/

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])
infixr 1 &//

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])
infixr 1 &.//

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a
infixr 1 $|

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $/

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $//

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $.//

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>
instance GHC.Show.Show node => GHC.Show.Show (Text.XML.Cursor.Generic.Cursor node)


-- | DOM-based parsing and rendering.
--   
--   This module requires that all entities be resolved at parsing. If you
--   need to interact with unresolved entities, please use
--   <a>Text.XML.Unresolved</a>. This is the recommended module for most
--   uses cases.
--   
--   While many of the datatypes in this module are simply re-exported from
--   <tt>Data.XML.Types</tt>, <a>Document</a>, <a>Node</a> and
--   <a>Element</a> are all redefined here to disallow the possibility of
--   unresolved entities. Conversion functions are provided to switch
--   between the two sets of datatypes.
--   
--   For simpler, bidirectional traversal of the DOM tree, see the
--   <a>Text.XML.Cursor</a> module.
module Text.XML
data Document
Document :: Prologue -> Element -> [Miscellaneous] -> Document
[documentPrologue] :: Document -> Prologue
[documentRoot] :: Document -> Element
[documentEpilogue] :: Document -> [Miscellaneous]
data Prologue :: *
Prologue :: [Miscellaneous] -> Maybe Doctype -> [Miscellaneous] -> Prologue
[prologueBefore] :: Prologue -> [Miscellaneous]
[prologueDoctype] :: Prologue -> Maybe Doctype
[prologueAfter] :: Prologue -> [Miscellaneous]
data Instruction :: *
Instruction :: Text -> Text -> Instruction
[instructionTarget] :: Instruction -> Text
[instructionData] :: Instruction -> Text
data Miscellaneous :: *
MiscInstruction :: Instruction -> Miscellaneous
MiscComment :: Text -> Miscellaneous
data Node
NodeElement :: Element -> Node
NodeInstruction :: Instruction -> Node
NodeContent :: Text -> Node
NodeComment :: Text -> Node
data Element
Element :: Name -> Map Name Text -> [Node] -> Element
[elementName] :: Element -> Name
[elementAttributes] :: Element -> Map Name Text
[elementNodes] :: Element -> [Node]

-- | A fully qualified name.
--   
--   Prefixes are not semantically important; they are included only to
--   simplify pass-through parsing. When comparing names with <a>Eq</a> or
--   <a>Ord</a> methods, prefixes are ignored.
--   
--   The <tt>IsString</tt> instance supports Clark notation; see
--   <a>http://www.jclark.com/xml/xmlns.htm</a> and
--   <a>http://infohost.nmt.edu/tcc/help/pubs/pylxml/etree-QName.html</a>.
--   Use the <tt>OverloadedStrings</tt> language extension for very simple
--   <tt>Name</tt> construction:
--   
--   <pre>
--   myname :: Name
--   myname = "{http://example.com/ns/my-namespace}my-name"
--   </pre>
data Name :: *
Name :: Text -> Maybe Text -> Maybe Text -> Name
[nameLocalName] :: Name -> Text
[nameNamespace] :: Name -> Maybe Text
[namePrefix] :: Name -> Maybe Text

-- | Note: due to the incredible complexity of DTDs, this type only
--   supports external subsets. I've tried adding internal subset types,
--   but they quickly gain more code than the rest of this module put
--   together.
--   
--   It is possible that some future version of this library might support
--   internal subsets, but I am no longer actively working on adding them.
data Doctype :: *
Doctype :: Text -> Maybe ExternalID -> Doctype
[doctypeName] :: Doctype -> Text
[doctypeID] :: Doctype -> Maybe ExternalID
data ExternalID :: *
SystemID :: Text -> ExternalID
PublicID :: Text -> Text -> ExternalID
readFile :: ParseSettings -> FilePath -> IO Document
parseLBS :: ParseSettings -> ByteString -> Either SomeException Document
parseLBS_ :: ParseSettings -> ByteString -> Document
sinkDoc :: MonadThrow m => ParseSettings -> Consumer ByteString m Document
parseText :: ParseSettings -> Text -> Either SomeException Document
parseText_ :: ParseSettings -> Text -> Document
sinkTextDoc :: MonadThrow m => ParseSettings -> Consumer Text m Document
fromEvents :: MonadThrow m => Consumer EventPos m Document
data UnresolvedEntityException
UnresolvedEntityException :: (Set Text) -> UnresolvedEntityException
data XMLException
InvalidXMLFile :: FilePath -> SomeException -> XMLException
writeFile :: RenderSettings -> FilePath -> Document -> IO ()
renderLBS :: RenderSettings -> Document -> ByteString
renderText :: RenderSettings -> Document -> Text
renderBytes :: (PrimMonad base, MonadBase base m) => RenderSettings -> Document -> ConduitM a ByteString m ()

-- | The default value for this type.
def :: Default a => a
data ParseSettings
psDecodeEntities :: ParseSettings -> DecodeEntities

-- | Whether the original xmlns attributes should be retained in the parsed
--   values. For more information on motivation, see:
--   
--   <a>https://github.com/snoyberg/xml/issues/38</a>
--   
--   Default: False
--   
--   Since 1.2.1
psRetainNamespaces :: ParseSettings -> Bool

-- | Default implementation of <a>DecodeEntities</a>: handles numeric
--   entities and the five standard character entities (lt, gt, amp, quot,
--   apos).
decodeXmlEntities :: DecodeEntities

-- | HTML4-compliant entity decoder. Handles numerics, the five standard
--   character entities, and the additional 248 entities defined by HTML 4
--   and XHTML 1.
--   
--   Note that HTML 5 introduces a drastically larger number of entities,
--   and this code does not recognize most of them.
decodeHtmlEntities :: DecodeEntities
data RenderSettings
rsPretty :: RenderSettings -> Bool

-- | Defines some top level namespace definitions to be used, in the form
--   of (prefix, namespace). This has absolutely no impact on the meaning
--   of your documents, but can increase readability by moving commonly
--   used namespace declarations to the top level.
rsNamespaces :: RenderSettings -> [(Text, Text)]

-- | Specify how to turn the unordered attributes used by the
--   <a>Text.XML</a> module into an ordered list.
rsAttrOrder :: RenderSettings -> Name -> Map Name Text -> [(Name, Text)]

-- | Determines if for a given text content the renderer should use a CDATA
--   node.
--   
--   Default: <tt>False</tt>
rsUseCDATA :: RenderSettings -> Content -> Bool

-- | Convenience function to create an ordering function suitable for use
--   as the value of <a>rsAttrOrder</a>. The ordering function is created
--   from an explicit ordering of the attributes, specified as a list of
--   tuples, as follows: In each tuple, the first component is the
--   <a>Name</a> of an element, and the second component is a list of
--   attributes names. When the given element is rendered, the attributes
--   listed, when present, appear first in the given order, followed by any
--   other attributes in arbitrary order. If an element does not appear,
--   all of its attributes are rendered in arbitrary order.
orderAttrs :: [(Name, [Name])] -> Name -> Map Name Text -> [(Name, Text)]
toXMLDocument :: Document -> Document
fromXMLDocument :: Document -> Either (Set Text) Document
toXMLNode :: Node -> Node
fromXMLNode :: Node -> Either (Set Text) Node
toXMLElement :: Element -> Element
fromXMLElement :: Element -> Either (Set Text) Element
instance GHC.Show.Show Text.XML.UnresolvedEntityException
instance Data.Data.Data Text.XML.Document
instance GHC.Classes.Eq Text.XML.Document
instance GHC.Show.Show Text.XML.Document
instance Data.Data.Data Text.XML.Node
instance GHC.Classes.Ord Text.XML.Node
instance GHC.Classes.Eq Text.XML.Node
instance GHC.Show.Show Text.XML.Node
instance Data.Data.Data Text.XML.Element
instance GHC.Classes.Ord Text.XML.Element
instance GHC.Classes.Eq Text.XML.Element
instance GHC.Show.Show Text.XML.Element
instance Control.DeepSeq.NFData Text.XML.Document
instance Control.DeepSeq.NFData Text.XML.Node
instance Control.DeepSeq.NFData Text.XML.Element
instance GHC.Show.Show Text.XML.XMLException
instance GHC.Exception.Exception Text.XML.XMLException
instance GHC.Exception.Exception Text.XML.UnresolvedEntityException
instance Text.Blaze.ToMarkup Text.XML.Document
instance Text.Blaze.ToMarkup Text.XML.Element
instance Text.Blaze.ToMarkup Text.XML.Node


-- | This module provides for simple DOM traversal. It is inspired by
--   XPath. There are two central concepts here:
--   
--   <ul>
--   <li>A <a>Cursor</a> represents a node in the DOM. It also contains
--   information on the node's <i>location</i>. While the <a>Node</a>
--   datatype will only know of its children, a <tt>Cursor</tt> knows about
--   its parent and siblings as well. (The underlying mechanism allowing
--   this is called a zipper, see
--   <a>http://www.haskell.org/haskellwiki/Zipper</a> and
--   <a>http://www.haskell.org/haskellwiki/Tying_the_Knot</a>.)</li>
--   <li>An <a>Axis</a>, in its simplest form, takes a <tt>Cursor</tt> and
--   returns a list of <tt>Cursor</tt>s. It is used for selections, such as
--   finding children, ancestors, etc. Axes can be chained together to
--   express complex rules, such as all children named <i>foo</i>.</li>
--   </ul>
--   
--   The terminology used in this module is taken directly from the XPath
--   specification: <a>http://www.w3.org/TR/xpath/</a>. For those familiar
--   with XPath, the one major difference is that attributes are not
--   considered nodes in this module.
module Text.XML.Cursor

-- | A cursor: contains an XML <a>Node</a> and pointers to its children,
--   ancestors and siblings.
type Cursor = Cursor Node

-- | The type of an Axis that returns a list of Cursors. They are roughly
--   modeled after <a>http://www.w3.org/TR/xpath/#axes</a>.
--   
--   Axes can be composed with <a>&gt;=&gt;</a>, where e.g. <tt>f &gt;=&gt;
--   g</tt> means that on all results of the <tt>f</tt> axis, the
--   <tt>g</tt> axis will be applied, and all results joined together.
--   Because Axis is just a type synonym for <tt>Cursor -&gt;
--   [Cursor]</tt>, it is possible to use other standard functions like
--   <a>&gt;&gt;=</a> or <a>concatMap</a> similarly.
--   
--   The operators <tt>&amp;|</tt>, <tt>&amp;/</tt>, <tt>&amp;//</tt> and
--   <tt>&amp;.//</tt> can be used to combine axes so that the second axis
--   works on the context nodes, children, descendants, respectively the
--   context node as well as its descendants of the results of the first
--   axis.
--   
--   The operators <tt>$|</tt>, <tt>$/</tt>, <tt>$//</tt> and <tt>$.//</tt>
--   can be used to apply an axis (right-hand side) to a cursor so that it
--   is applied on the cursor itself, its children, its descendants,
--   respectively itself and its descendants.
--   
--   Note that many of these operators also work on <i>generalised Axes</i>
--   that can return lists of something other than Cursors, for example
--   Content elements.
type Axis = Cursor -> [Cursor]

-- | Convert a <a>Document</a> to a <a>Cursor</a>. It will point to the
--   document root.
fromDocument :: Document -> Cursor

-- | Convert a <a>Node</a> to a <a>Cursor</a> (without parents).
fromNode :: Node -> Cursor

-- | Cut a cursor off from its parent. The idea is to allow restricting the
--   scope of queries on it.
cut :: Cursor -> Cursor

-- | The parent axis. As described in XPath: <i>the parent axis contains
--   the parent of the context node, if there is one</i>.
--   
--   Every node but the root element of the document has a parent. Parent
--   nodes will always be <tt>NodeElement</tt>s.
parent :: Axis node

-- | The preceding-sibling axis. XPath: <i>the preceding-sibling axis
--   contains all the preceding siblings of the context node [...]</i>.
precedingSibling :: Axis node

-- | The following-sibling axis. XPath: <i>the following-sibling axis
--   contains all the following siblings of the context node [...]</i>.
followingSibling :: Axis node

-- | The child axis. XPath: <i>the child axis contains the children of the
--   context node</i>.
child :: Cursor node -> [Cursor node]

-- | The current node.
node :: Cursor node -> node

-- | The preceding axis. XPath: <i>the preceding axis contains all nodes in
--   the same document as the context node that are before the context node
--   in document order, excluding any ancestors and excluding attribute
--   nodes and namespace nodes</i>.
preceding :: Axis node

-- | The following axis. XPath: <i>the following axis contains all nodes in
--   the same document as the context node that are after the context node
--   in document order, excluding any descendants and excluding attribute
--   nodes and namespace nodes</i>.
following :: Axis node

-- | The ancestor axis. XPath: <i>the ancestor axis contains the ancestors
--   of the context node; the ancestors of the context node consist of the
--   parent of context node and the parent's parent and so on; thus, the
--   ancestor axis will always include the root node, unless the context
--   node is the root node</i>.
ancestor :: Axis node

-- | The descendant axis. XPath: <i>the descendant axis contains the
--   descendants of the context node; a descendant is a child or a child of
--   a child and so on; thus the descendant axis never contains attribute
--   or namespace nodes</i>.
descendant :: Axis node

-- | Modify an axis by adding the context node itself as the first element
--   of the result list.
orSelf :: Axis node -> Axis node

-- | Filter cursors that don't pass a check.
check :: Boolean b => (Cursor -> b) -> Axis

-- | Filter nodes that don't pass a check.
checkNode :: Boolean b => (Node -> b) -> Axis

-- | Filter elements that don't pass a check, and remove all non-elements.
checkElement :: Boolean b => (Element -> b) -> Axis

-- | Filter elements that don't pass a name check, and remove all
--   non-elements.
checkName :: Boolean b => (Name -> b) -> Axis

-- | Remove all non-elements. Compare roughly to XPath: <i>A node test * is
--   true for any node of the principal node type. For example, child::*
--   will select all element children of the context node [...]</i>.
anyElement :: Axis

-- | Select only those elements with a matching tag name. XPath: <i>A node
--   test that is a QName is true if and only if the type of the node (see
--   [5 Data Model]) is the principal node type and has an expanded-name
--   equal to the expanded-name specified by the QName.</i>
element :: Name -> Axis

-- | Select only those elements with a loosely matching tag name. Namespace
--   and case are ignored. XPath: <i>A node test that is a QName is true if
--   and only if the type of the node (see [5 Data Model]) is the principal
--   node type and has an expanded-name equal to the expanded-name
--   specified by the QName.</i>
laxElement :: Text -> Axis

-- | Select only text nodes, and directly give the <tt>Content</tt> values.
--   XPath: <i>The node test text() is true for any text node.</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
content :: Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). XPath: <i>the attribute axis contains the attributes of the
--   context node; the axis will be empty unless the context node is an
--   element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
attribute :: Name -> Cursor -> [Text]

-- | Select attributes on the current element (or nothing if it is not an
--   element). Namespace and case are ignored. XPath: <i>the attribute axis
--   contains the attributes of the context node; the axis will be empty
--   unless the context node is an element</i>
--   
--   Note that this is not strictly an <a>Axis</a>, but will work with most
--   combinators.
--   
--   The return list of the generalised axis contains as elements lists of
--   <tt>Content</tt> elements, each full list representing an attribute
--   value.
laxAttribute :: Text -> Cursor -> [Text]

-- | Select only those element nodes with the given attribute.
hasAttribute :: Name -> Axis

-- | Select only those element nodes containing the given attribute
--   key/value pair.
attributeIs :: Name -> Text -> Axis

-- | Apply a function to the result of an axis.
(&|) :: (Cursor node -> [a]) -> (a -> b) -> (Cursor node -> [b])
infixr 1 &|

-- | Combine two axes so that the second works on the children of the
--   results of the first.
(&/) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])
infixr 1 &/

-- | Combine two axes so that the second works on the descendants of the
--   results of the first.
(&//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])
infixr 1 &//

-- | Combine two axes so that the second works on both the result nodes,
--   and their descendants.
(&.//) :: Axis node -> (Cursor node -> [a]) -> (Cursor node -> [a])
infixr 1 &.//

-- | Apply an axis to a 'Cursor node'.
($|) :: Cursor node -> (Cursor node -> a) -> a
infixr 1 $|

-- | Apply an axis to the children of a 'Cursor node'.
($/) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $/

-- | Apply an axis to the descendants of a 'Cursor node'.
($//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $//

-- | Apply an axis to a 'Cursor node' as well as its descendants.
($.//) :: Cursor node -> (Cursor node -> [a]) -> [a]
infixr 1 $.//

-- | Left-to-right Kleisli composition of monads.
(>=>) :: Monad m => (a -> m b) -> (b -> m c) -> a -> m c
infixr 1 >=>

-- | Something that can be used in a predicate check as a boolean.
class Boolean a
bool :: Boolean a => a -> Bool
force :: (Exception e, MonadThrow f) => e -> [a] -> f a
forceM :: (Exception e, MonadThrow f) => e -> [f a] -> f a
instance Text.XML.Cursor.Boolean GHC.Types.Bool
instance Text.XML.Cursor.Boolean [a]
instance Text.XML.Cursor.Boolean (GHC.Base.Maybe a)
instance Text.XML.Cursor.Boolean (Data.Either.Either a b)
