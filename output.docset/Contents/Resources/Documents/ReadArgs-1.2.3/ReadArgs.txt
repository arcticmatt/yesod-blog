-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Simple command line argument parsing
--   
--   ReadArgs provides the <tt>readArgs</tt> IO action, which lets you tell
--   the compiler to parse the command line arguments to fit the type
--   signature you give.
--   
--   For example <tt>(a :: Int, b :: String, c :: Float) &lt;-
--   readArgs</tt> would parse the first runtime argument as an
--   <tt>Int</tt>, the second as a <tt>String</tt> (no quotes required) and
--   the third as a <tt>Float</tt>.
--   
--   If the runtime arguments are incompatible with the type signature,
--   then a simple usage statement is given of the types needed.
--   
--   Continuing the previous example, if it was used in a program named
--   <tt>Example</tt>, the error message for the above action would be:
--   
--   <pre>
--   usage: Example Int String Float
--   </pre>
--   
--   Any type that has both <tt>Typeable</tt> and <tt>Read</tt> instances
--   can be used. <tt>Char</tt>, <tt>String</tt>, and <tt>Text</tt> are
--   handled specially so that command line arguments for both do not
--   require quotes (as their <tt>Read</tt> instances do). A special
--   instance is provided for <tt>FilePath</tt> so that no constructor or
--   quotes are required.
--   
--   <tt>readArgs</tt> also supports optional arguments and variadic
--   arguments. Optional arguments are specified using <tt>Maybe</tt>, and
--   variadic arguments using a list. <tt>(a :: Int, b :: Maybe String, c
--   :: [Float]) &lt;- readArgs</tt> would successfully parse any of the
--   following sets of command line arguments:
--   
--   <pre>
--   Example 1
--   Example 1 2 3 4
--   Example 1 foo
--   Example 1 foo 2 3 4
--   </pre>
--   
--   But not
--   
--   <pre>
--   Example
--   Example foo
--   Example 1.0
--   </pre>
--   
--   Usage statements for optional and variadic arguments use command-line
--   parlance:
--   
--   <pre>
--   usage: Example Int [String] [Float..]
--   </pre>
--   
--   Note that both optional and variadic parsers are greedy by default (so
--   <tt>Example 1 2 3 4</tt> was parsed as <tt>(1, "2", [3.0,4.0])</tt>.
--   They may both be made non-greedy through use of the <tt>NonGreedy</tt>
--   constructor:
--   
--   <pre>
--   ( a :: Int
--   , NonGreedy b :: NonGreedy Maybe String
--   , NonGreedy c :: NonGreedy [] Float
--   ) &lt;- readArgs
--   </pre>
@package ReadArgs
@version 1.2.3

module ReadArgs

-- | parse the desired argument tuple from the command line or print a
--   simple usage statment and quit
readArgs :: ArgumentTuple a => IO a

-- | read args from the given strings or print a simple usage statment and
--   quit (so you can do option parsing first)
readArgsFrom :: ArgumentTuple a => [String] -> IO a

-- | a class for types that can be parsed from exactly one command line
--   argument
class Arguable a
parse :: Arguable a => String -> Maybe a

-- | name's argument will usually be undefined, so when defining instances
--   of Arguable, it should be lazy in its argument
name :: Arguable a => a -> String

-- | all types that are typeable and readable can be used as simple
--   arguments

-- | string is a special case, so that we don't force the user to
--   double-quote their input

-- | Text is a special case, so that we don't force the user to
--   double-quote their input

-- | FilePath is a special case, so that we don't force the user to
--   double-quote their input

-- | char is a special case, so that we don't force the user to
--   single-quote their input

-- | a class for types that can be parsed from some number of command line
--   arguments
class Argument a
parseArg :: Argument a => [String] -> [(a, [String])]

-- | argName's argument will usually be undefined, so when defining
--   instances of Arguable, it should be lazy in its argument
argName :: Argument a => a -> String

-- | use the arguable tyep to just parse a single argument

-- | use Maybe when it should be parsed from one or zero (greedily)

-- | use a list when it should be parsed from zero or more (greedily)

-- | a wrapper type to indicate a non-greedy list or maybe
newtype NonGreedy m a
NonGreedy :: m a -> NonGreedy m a
[unNonGreedy] :: NonGreedy m a -> m a

-- | use NonGreedy when it should be parsed non-greedily (e.g.
--   <tt>(NonGreedy xs :: NonGreedy [] Int, x :: Maybe Float) &lt;-
--   readArgs</tt>)

-- | make sure strings are handled as a separate type, not a list of chars

-- | a class for tuples of types that can be parsed from the entire list of
--   arguments
class ArgumentTuple a
parseArgsFrom :: ArgumentTuple a => [String] -> Maybe a

-- | usageFor's argument will usually be undefined, so when defining
--   instances of Arguable, it should be lazy in its argument
usageFor :: ArgumentTuple a => a -> String

-- | use () for no arguments

-- | use :&amp; to construct arbitrary length tuples of any parsable
--   arguments
data (:&) a b
(:&) :: a -> b -> (:&) a b
instance (GHC.Classes.Eq b, GHC.Classes.Eq a) => GHC.Classes.Eq (a ReadArgs.:& b)
instance (GHC.Show.Show b, GHC.Show.Show a) => GHC.Show.Show (a ReadArgs.:& b)
instance GHC.Classes.Eq (m a) => GHC.Classes.Eq (ReadArgs.NonGreedy m a)
instance GHC.Show.Show (m a) => GHC.Show.Show (ReadArgs.NonGreedy m a)
instance (Data.Typeable.Internal.Typeable t, GHC.Read.Read t) => ReadArgs.Arguable t
instance ReadArgs.Arguable GHC.Base.String
instance ReadArgs.Arguable Data.Text.Internal.Text
instance ReadArgs.Arguable Filesystem.Path.Internal.FilePath
instance ReadArgs.Arguable GHC.Types.Char
instance ReadArgs.Arguable a => ReadArgs.Argument a
instance ReadArgs.Arguable a => ReadArgs.Argument (GHC.Base.Maybe a)
instance ReadArgs.Arguable a => ReadArgs.Argument [a]
instance ReadArgs.Argument (m a) => ReadArgs.Argument (ReadArgs.NonGreedy m a)
instance ReadArgs.Argument GHC.Base.String
instance ReadArgs.ArgumentTuple ()
instance (ReadArgs.Argument a, ReadArgs.ArgumentTuple y) => ReadArgs.ArgumentTuple (a ReadArgs.:& y)
instance ReadArgs.Argument a => ReadArgs.ArgumentTuple a
instance (ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (b, a)
instance (ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (c, b, a)
instance (ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (d, c, b, a)
instance (ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (e, d, c, b, a)
instance (ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (f, e, d, c, b, a)
instance (ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (g, f, e, d, c, b, a)
instance (ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (i, h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument j, ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (j, i, h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument k, ReadArgs.Argument j, ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (k, j, i, h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument l, ReadArgs.Argument k, ReadArgs.Argument j, ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (l, k, j, i, h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument m, ReadArgs.Argument l, ReadArgs.Argument k, ReadArgs.Argument j, ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (m, l, k, j, i, h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument n, ReadArgs.Argument m, ReadArgs.Argument l, ReadArgs.Argument k, ReadArgs.Argument j, ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (n, m, l, k, j, i, h, g, f, e, d, c, b, a)
instance (ReadArgs.Argument o, ReadArgs.Argument n, ReadArgs.Argument m, ReadArgs.Argument l, ReadArgs.Argument k, ReadArgs.Argument j, ReadArgs.Argument i, ReadArgs.Argument h, ReadArgs.Argument g, ReadArgs.Argument f, ReadArgs.Argument e, ReadArgs.Argument d, ReadArgs.Argument c, ReadArgs.Argument b, ReadArgs.Argument a) => ReadArgs.ArgumentTuple (o, n, m, l, k, j, i, h, g, f, e, d, c, b, a)
