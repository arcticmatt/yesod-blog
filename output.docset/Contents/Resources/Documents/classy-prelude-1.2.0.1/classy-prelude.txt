-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | A typeclass-based Prelude.
--   
--   Modern best practices without name collisions. No partial functions
--   are exposed, but modern data structures are, without requiring import
--   lists. Qualified modules also are not needed: instead operations are
--   based on type-classes from the mono-traversable package.
@package classy-prelude
@version 1.2.0.1

module ClassyPrelude

-- | We define our own <a>undefined</a> which is marked as deprecated. This
--   makes it useful to use during development, but lets you more easily
--   get notifications if you accidentally ship partial code in production.
--   
--   The classy prelude recommendation for when you need to really have a
--   partial function in production is to use <a>error</a> with a very
--   descriptive message so that, in case an exception is thrown, you get
--   more information than <tt><a>Prelude</a>.<a>undefined</a></tt>.
--   
--   Since 0.5.5

-- | <i>Deprecated: It is highly recommended that you either avoid partial
--   functions or provide meaningful error messages</i>
undefined :: HasCallStack => a
(++) :: Monoid m => m -> m -> m
infixr 5 ++

-- | The class of semigroups (types with an associative binary operation).
class Semigroup a

-- | An associative operation.
--   
--   <pre>
--   (a <a>&lt;&gt;</a> b) <a>&lt;&gt;</a> c = a <a>&lt;&gt;</a> (b <a>&lt;&gt;</a> c)
--   </pre>
--   
--   If <tt>a</tt> is also a <a>Monoid</a> we further require
--   
--   <pre>
--   (<a>&lt;&gt;</a>) = <a>mappend</a>
--   </pre>
(<>) :: Semigroup a => a -> a -> a

-- | Reduce a non-empty list with <tt>&lt;&gt;</tt>
--   
--   The default definition should be sufficient, but this can be
--   overridden for efficiency.
sconcat :: Semigroup a => NonEmpty a -> a

-- | Repeat a value <tt>n</tt> times.
--   
--   Given that this works on a <a>Semigroup</a> it is allowed to fail if
--   you request 0 or fewer repetitions, and the default definition will do
--   so.
--   
--   By making this a member of the class, idempotent semigroups and
--   monoids can upgrade this to execute in <i>O(1)</i> by picking
--   <tt>stimes = stimesIdempotent</tt> or <tt>stimes =
--   stimesIdempotentMonoid</tt> respectively.
stimes :: (Semigroup a, Integral b) => b -> a -> a

-- | Provide a Semigroup for an arbitrary Monoid.
data WrappedMonoid m :: * -> *

-- | <a>&amp;&amp;</a> lifted to an Applicative.
(<&&>) :: Applicative a => a Bool -> a Bool -> a Bool
infixr 3 <&&>

-- | <a>||</a> lifted to an Applicative.
(<||>) :: Applicative a => a Bool -> a Bool -> a Bool
infixr 2 <||>

-- | Only perform the action if the predicate returns <a>True</a>.
--   
--   Since 0.9.2
whenM :: Monad m => m Bool -> m () -> m ()

-- | Only perform the action if the predicate returns <a>False</a>.
--   
--   Since 0.9.2
unlessM :: Monad m => m Bool -> m () -> m ()

-- | Generalized version of <a>atomically</a>.
atomically :: MonadIO m => STM a -> m a

-- | Synonym for <a>always</a>.
alwaysSTM :: STM Bool -> STM ()

-- | Synonym for <a>alwaysSucceeds</a>.
alwaysSucceedsSTM :: STM a -> STM ()

-- | Synonym for <a>retry</a>.
retrySTM :: STM a

-- | Synonym for <a>orElse</a>.
orElseSTM :: STM a -> STM a -> STM a

-- | Synonym for <a>check</a>.
checkSTM :: Bool -> STM ()

-- | Convert a <a>PrimBase</a> to another monad with the same state token.
primToPrim :: (PrimBase m1, PrimMonad m2, (~) * (PrimState m1) (PrimState m2)) => m1 a -> m2 a

-- | Convert a <a>PrimBase</a> with a <a>RealWorld</a> state token to
--   <a>IO</a>
primToIO :: (PrimBase m, (~) * (PrimState m) RealWorld) => m a -> IO a

-- | Convert a <a>PrimBase</a> to <a>ST</a>
primToST :: PrimBase m => m a -> ST (PrimState m) a

-- | The <a>trace</a> function outputs the trace message given as its first
--   argument, before returning the second argument as its result.
--   
--   For example, this returns the value of <tt>f x</tt> but first outputs
--   the message.
--   
--   <pre>
--   trace ("calling f with x = " ++ show x) (f x)
--   </pre>
--   
--   The <a>trace</a> function should <i>only</i> be used for debugging, or
--   for monitoring execution. The function is not referentially
--   transparent: its type indicates that it is a pure function but it has
--   the side effect of outputting the trace message.
trace :: String -> a -> a

-- | Like <a>trace</a>, but uses <a>show</a> on the argument to convert it
--   to a <a>String</a>.
--   
--   This makes it convenient for printing the values of interesting
--   variables or expressions inside a function. For example here we print
--   the value of the variables <tt>x</tt> and <tt>z</tt>:
--   
--   <pre>
--   f x y =
--       traceShow (x, z) $ result
--     where
--       z = ...
--       ...
--   </pre>
traceShow :: Show a => a -> b -> b

-- | Since 0.5.9
traceId :: String -> String

-- | Since 0.5.9
traceM :: (Monad m) => String -> m ()

-- | Since 0.5.9
traceShowId :: (Show a) => a -> a

-- | Since 0.5.9
traceShowM :: (Show a, Monad m) => a -> m ()

-- | If the first argument evaluates to <a>True</a>, then the result is the
--   second argument. Otherwise an <tt>AssertionFailed</tt> exception is
--   raised, containing a <a>String</a> with the source file and line
--   number of the call to <a>assert</a>.
--   
--   Assertions can normally be turned on or off with a compiler flag (for
--   GHC, assertions are normally on unless optimisation is turned on with
--   <tt>-O</tt> or the <tt>-fignore-asserts</tt> option is given). When
--   assertions are turned off, the first argument to <a>assert</a> is
--   ignored, and the second argument is returned as the result.
assert :: Bool -> a -> a

-- | Locale representing American usage.
--   
--   <a>knownTimeZones</a> contains only the ten time-zones mentioned in
--   RFC 822 sec. 5: "UT", "GMT", "EST", "EDT", "CST", "CDT", "MST", "MDT",
--   "PST", "PDT". Note that the parsing functions will regardless parse
--   single-letter military time-zones and +HHMM format.
defaultTimeLocale :: TimeLocale

-- | Representable types of kind *. This class is derivable in GHC with the
--   DeriveGeneric flag on.
class Generic a

-- | Identity functor and monad. (a non-strict monad)
newtype Identity a :: * -> *
Identity :: a -> Identity a
[runIdentity] :: Identity a -> a

-- | See examples in <a>Control.Monad.Reader</a>. Note, the partially
--   applied function type <tt>(-&gt;) r</tt> is a simple reader monad. See
--   the <tt>instance</tt> declaration below.
class Monad m => MonadReader r (m :: * -> *) | m -> r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Retrieves the monad environment.
ask :: MonadReader r m => m r

-- | Retrieves a function of the current environment.
asks :: MonadReader r m => (r -> a) -> m a

-- | The reader monad transformer, which adds a read-only environment to
--   the given monad.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
newtype ReaderT k r (m :: k -> *) (a :: k) :: forall k. * -> (k -> *) -> k -> *
ReaderT :: (r -> m a) -> ReaderT k r
[runReaderT] :: ReaderT k r -> r -> m a

-- | The parameterizable reader monad.
--   
--   Computations are functions of a shared environment.
--   
--   The <a>return</a> function ignores the environment, while
--   <tt>&gt;&gt;=</tt> passes the inherited environment to both
--   subcomputations.
type Reader r = ReaderT * r Identity

-- | Convert a <a>ByteString</a> into a storable <a>Vector</a>.
toByteVector :: ByteString -> SVector Word8

-- | Convert a storable <a>Vector</a> into a <a>ByteString</a>.
fromByteVector :: SVector Word8 -> ByteString

-- | Haskell defines operations to read and write characters from and to
--   files, represented by values of type <tt>Handle</tt>. Each value of
--   this type is a <i>handle</i>: a record used by the Haskell run-time
--   system to <i>manage</i> I/O with file system objects. A handle has at
--   least the following properties:
--   
--   <ul>
--   <li>whether it manages input or output or both;</li>
--   <li>whether it is <i>open</i>, <i>closed</i> or
--   <i>semi-closed</i>;</li>
--   <li>whether the object is seekable;</li>
--   <li>whether buffering is disabled, or enabled on a line or block
--   basis;</li>
--   <li>a buffer (whose length may be zero).</li>
--   </ul>
--   
--   Most handles will also have a current I/O position indicating where
--   the next input or output operation will occur. A handle is
--   <i>readable</i> if it manages only input or both input and output;
--   likewise, it is <i>writable</i> if it manages only output or both
--   input and output. A handle is <i>open</i> when first allocated. Once
--   it is closed it can no longer be used for either input or output,
--   though an implementation cannot re-use its storage while references
--   remain to it. Handles are in the <a>Show</a> and <a>Eq</a> classes.
--   The string produced by showing a handle is system dependent; it should
--   include enough information to identify the handle for debugging. A
--   handle is equal according to <a>==</a> only to itself; no attempt is
--   made to compare the internal state of different handles for equality.
data Handle :: *

-- | A handle managing input from the Haskell program's standard input
--   channel.
stdin :: Handle

-- | A handle managing output to the Haskell program's standard output
--   channel.
stdout :: Handle

-- | A handle managing output to the Haskell program's standard error
--   channel.
stderr :: Handle

-- | Originally <a>yield</a>.
yieldThread :: MonadBase IO m => m ()

-- | <a>waitSTM</a> for any <a>MonadIO</a>
waitAsync :: MonadIO m => Async a -> m a

-- | <a>pollSTM</a> for any <a>MonadIO</a>
pollAsync :: MonadIO m => Async a -> m (Maybe (Either SomeException a))

-- | <a>waitCatchSTM</a> for any <a>MonadIO</a>
waitCatchAsync :: MonadIO m => Async a -> m (Either SomeException a)

-- | <a>cancel</a> generalized to any <a>MonadIO</a>
cancel :: MonadIO m => Async a -> m ()

-- | <a>cancel</a> an <a>Async</a> with the given exception. It is
--   converted to an async exception via <a>toAsyncException</a> first.
cancelWith :: (MonadIO m, Exception e) => Async a -> e -> m ()

-- | <a>link</a> generalized to any <a>MonadIO</a>
linkAsync :: MonadIO m => Async a -> m ()

-- | <a>link2</a> generalized to any <a>MonadIO</a>
link2Async :: MonadIO m => Async a -> Async b -> m ()
map :: Functor f => (a -> b) -> f a -> f b
readMay :: (Element c ~ Char, MonoFoldable c, Read a) => c -> Maybe a
zip :: Zip f => forall a b. f a -> f b -> f (a, b)
zip3 :: Zip3 f => forall a b c. f a -> f b -> f c -> f (a, b, c)
zip4 :: Zip4 f => forall a b c d. f a -> f b -> f c -> f d -> f (a, b, c, d)
zip5 :: Zip5 f => forall a b c d e. f a -> f b -> f c -> f d -> f e -> f (a, b, c, d, e)
zip6 :: Zip6 f => forall a b c d e g. f a -> f b -> f c -> f d -> f e -> f g -> f (a, b, c, d, e, g)
zip7 :: Zip7 f => forall a b c d e g h. f a -> f b -> f c -> f d -> f e -> f g -> f h -> f (a, b, c, d, e, g, h)
unzip :: Zip f => forall a b. f (a, b) -> (f a, f b)
unzip3 :: Zip3 f => forall a b c. f (a, b, c) -> (f a, f b, f c)
unzip4 :: Zip4 f => forall a b c d. f (a, b, c, d) -> (f a, f b, f c, f d)
unzip5 :: Zip5 f => forall a b c d e. f (a, b, c, d, e) -> (f a, f b, f c, f d, f e)
unzip6 :: Zip6 f => forall a b c d e g. f (a, b, c, d, e, g) -> (f a, f b, f c, f d, f e, f g)
unzip7 :: Zip7 f => forall a b c d e g h. f (a, b, c, d, e, g, h) -> (f a, f b, f c, f d, f e, f g, f h)
zipWith :: Zip f => forall a b c. (a -> b -> c) -> f a -> f b -> f c
zipWith3 :: Zip3 f => forall a b c d. (a -> b -> c -> d) -> f a -> f b -> f c -> f d
zipWith4 :: Zip4 f => forall a b c d e. (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
zipWith5 :: Zip5 f => forall a b c d e g. (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
zipWith6 :: Zip6 f => forall a b c d e g h. (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
zipWith7 :: Zip7 f => forall a b c d e g h i. (a -> b -> c -> d -> e -> g -> h -> i) -> f a -> f b -> f c -> f d -> f e -> f g -> f h -> f i

-- | same behavior as <a>nub</a>, but requires <a>Hashable</a> &amp;
--   <a>Eq</a> and is <tt>O(n log n)</tt>
--   
--   <a>https://github.com/nh2/haskell-ordnub</a>
hashNub :: (Hashable a, Eq a) => [a] -> [a]

-- | same behavior as <a>nub</a>, but requires <a>Ord</a> and is <tt>O(n
--   log n)</tt>
--   
--   <a>https://github.com/nh2/haskell-ordnub</a>
ordNub :: (Ord a) => [a] -> [a]

-- | same behavior as <a>nubBy</a>, but requires <a>Ord</a> and is <tt>O(n
--   log n)</tt>
--   
--   <a>https://github.com/nh2/haskell-ordnub</a>
ordNubBy :: (Ord b) => (a -> b) -> (a -> a -> Bool) -> [a] -> [a]

-- | Sort elements using the user supplied function to project something
--   out of each element. Inspired by
--   <a>http://hackage.haskell.org/packages/archive/base/latest/doc/html/GHC-Exts.html#v:sortWith</a>.
sortWith :: (Ord a, IsSequence c) => (Element c -> a) -> c -> c

-- | <a>repeat</a> <tt>x</tt> is an infinite list, with <tt>x</tt> the
--   value of every element.
repeat :: a -> [a]

-- | An alias for <a>difference</a>.
(\\) :: SetContainer a => a -> a -> a
infixl 9 \\

-- | An alias for <a>intersection</a>.
intersect :: SetContainer a => a -> a -> a

-- | Conversion of values to readable <a>String</a>s.
--   
--   Derived instances of <a>Show</a> have the following properties, which
--   are compatible with derived instances of <a>Read</a>:
--   
--   <ul>
--   <li>The result of <a>show</a> is a syntactically correct Haskell
--   expression containing only constants, given the fixity declarations in
--   force at the point where the type is declared. It contains only the
--   constructor names defined in the data type, parentheses, and spaces.
--   When labelled constructor fields are used, braces, commas, field
--   names, and equal signs are also used.</li>
--   <li>If the constructor is defined to be an infix operator, then
--   <a>showsPrec</a> will produce infix applications of the
--   constructor.</li>
--   <li>the representation will be enclosed in parentheses if the
--   precedence of the top-level constructor in <tt>x</tt> is less than
--   <tt>d</tt> (associativity is ignored). Thus, if <tt>d</tt> is
--   <tt>0</tt> then the result is never surrounded in parentheses; if
--   <tt>d</tt> is <tt>11</tt> it is always surrounded in parentheses,
--   unless it is an atomic expression.</li>
--   <li>If the constructor is defined using record syntax, then
--   <a>show</a> will produce the record-syntax form, with the fields given
--   in the same order as the original declaration.</li>
--   </ul>
--   
--   For example, given the declarations
--   
--   <pre>
--   infixr 5 :^:
--   data Tree a =  Leaf a  |  Tree a :^: Tree a
--   </pre>
--   
--   the derived instance of <a>Show</a> is equivalent to
--   
--   <pre>
--   instance (Show a) =&gt; Show (Tree a) where
--   
--          showsPrec d (Leaf m) = showParen (d &gt; app_prec) $
--               showString "Leaf " . showsPrec (app_prec+1) m
--            where app_prec = 10
--   
--          showsPrec d (u :^: v) = showParen (d &gt; up_prec) $
--               showsPrec (up_prec+1) u .
--               showString " :^: "      .
--               showsPrec (up_prec+1) v
--            where up_prec = 5
--   </pre>
--   
--   Note that right-associativity of <tt>:^:</tt> is ignored. For example,
--   
--   <ul>
--   <li><tt><a>show</a> (Leaf 1 :^: Leaf 2 :^: Leaf 3)</tt> produces the
--   string <tt>"Leaf 1 :^: (Leaf 2 :^: Leaf 3)"</tt>.</li>
--   </ul>
class Show a

-- | Convert a value to a readable <a>String</a>.
--   
--   <a>showsPrec</a> should satisfy the law
--   
--   <pre>
--   showsPrec d x r ++ s  ==  showsPrec d x (r ++ s)
--   </pre>
--   
--   Derived instances of <a>Read</a> and <a>Show</a> satisfy the
--   following:
--   
--   <ul>
--   <li><tt>(x,"")</tt> is an element of <tt>(<a>readsPrec</a> d
--   (<a>showsPrec</a> d x ""))</tt>.</li>
--   </ul>
--   
--   That is, <a>readsPrec</a> parses the string produced by
--   <a>showsPrec</a>, and delivers the value that <a>showsPrec</a> started
--   with.
showsPrec :: Show a => Int -> a -> ShowS

-- | A specialised variant of <a>showsPrec</a>, using precedence context
--   zero, and returning an ordinary <a>String</a>.
show :: Show a => a -> String

-- | The method <a>showList</a> is provided to allow the programmer to give
--   a specialised way of showing lists of values. For example, this is
--   used by the predefined <a>Show</a> instance of the <a>Char</a> type,
--   where values of type <a>String</a> should be shown in double quotes,
--   rather than between square brackets.
showList :: Show a => [a] -> ShowS
tshow :: Show a => a -> Text
tlshow :: Show a => a -> LText

-- | Convert a character to lower case.
--   
--   Character-based case conversion is lossy in comparison to string-based
--   <a>toLower</a>. For instance, İ will be converted to i, instead of i̇.
charToLower :: Char -> Char

-- | Convert a character to upper case.
--   
--   Character-based case conversion is lossy in comparison to string-based
--   <a>toUpper</a>. For instance, ß won't be converted to SS.
charToUpper :: Char -> Char

-- | Strictly read a file into a <a>ByteString</a>.
readFile :: MonadIO m => FilePath -> m ByteString

-- | Strictly read a file into a <a>Text</a> using a UTF-8 character
--   encoding. In the event of a character encoding error, a Unicode
--   replacement character will be used (a.k.a., <tt>lenientDecode</tt>).
readFileUtf8 :: MonadIO m => FilePath -> m Text

-- | Write a <a>ByteString</a> to a file.
writeFile :: MonadIO m => FilePath -> ByteString -> m ()

-- | Write a <a>Text</a> to a file using a UTF-8 character encoding.
writeFileUtf8 :: MonadIO m => FilePath -> Text -> m ()

-- | Strictly read the contents of the given <a>Handle</a> into a
--   <a>ByteString</a>.
hGetContents :: MonadIO m => Handle -> m ByteString

-- | Write a <a>ByteString</a> to the given <a>Handle</a>.
hPut :: MonadIO m => Handle -> ByteString -> m ()

-- | Read a single chunk of data as a <a>ByteString</a> from the given
--   <a>Handle</a>.
--   
--   Under the surface, this uses <a>hGetSome</a> with the default chunk
--   size.
hGetChunk :: MonadIO m => Handle -> m ByteString
print :: (Show a, MonadIO m) => a -> m ()

-- | Computation <a>hClose</a> <tt>hdl</tt> makes handle <tt>hdl</tt>
--   closed. Before the computation finishes, if <tt>hdl</tt> is writable
--   its buffer is flushed as for <a>hFlush</a>. Performing <a>hClose</a>
--   on a handle that has already been closed has no effect; doing so is
--   not an error. All other operations on a closed handle will fail. If
--   <a>hClose</a> fails for any reason, any further operations (apart from
--   <a>hClose</a>) on the handle will still fail as if <tt>hdl</tt> had
--   been successfully closed.
hClose :: Handle -> IO ()

-- | A difference list is a function that, given a list, returns the
--   original contents of the difference list prepended to the given list.
--   
--   This structure supports <i>O(1)</i> append and snoc operations on
--   lists, making it very useful for append-heavy uses (esp. left-nested
--   uses of <a>++</a>), such as logging and pretty printing.
--   
--   Here is an example using DList as the state type when printing a tree
--   with the Writer monad:
--   
--   <pre>
--   import Control.Monad.Writer
--   import Data.DList
--   
--   data Tree a = Leaf a | Branch (Tree a) (Tree a)
--   
--   flatten_writer :: Tree x -&gt; DList x
--   flatten_writer = snd . runWriter . flatten
--       where
--         flatten (Leaf x)     = tell (singleton x)
--         flatten (Branch x y) = flatten x &gt;&gt; flatten y
--   </pre>
data DList a :: * -> *

-- | Force type to a <a>DList</a>
--   
--   Since 0.11.0
asDList :: DList a -> DList a

-- | Synonym for <a>apply</a>
--   
--   Since 0.11.0
applyDList :: DList a -> [a] -> [a]
asByteString :: ByteString -> ByteString
asLByteString :: LByteString -> LByteString
asHashMap :: HashMap k v -> HashMap k v
asHashSet :: HashSet a -> HashSet a
asText :: Text -> Text
asLText :: LText -> LText
asList :: [a] -> [a]
asMap :: Map k v -> Map k v
asIntMap :: IntMap v -> IntMap v
asMaybe :: Maybe a -> Maybe a
asSet :: Set a -> Set a
asIntSet :: IntSet -> IntSet
asVector :: Vector a -> Vector a
asUVector :: UVector a -> UVector a
asSVector :: SVector a -> SVector a
asString :: [Char] -> [Char]
