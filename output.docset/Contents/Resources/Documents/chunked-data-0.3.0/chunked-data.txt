-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Typeclasses for dealing with various chunked data representations
--   
--   Originally present in classy-prelude.
@package chunked-data
@version 0.3.0

module Data.IOData

-- | Data which can be read to and from files and handles.
--   
--   Note that, for lazy sequences, these operations may perform lazy I/O.
class IOData a
readFile :: (IOData a, MonadIO m) => FilePath -> m a
writeFile :: (IOData a, MonadIO m) => FilePath -> a -> m ()
getLine :: (IOData a, MonadIO m) => m a
hGetContents :: (IOData a, MonadIO m) => Handle -> m a
hGetLine :: (IOData a, MonadIO m) => Handle -> m a
hPut :: (IOData a, MonadIO m) => Handle -> a -> m ()
hPutStrLn :: (IOData a, MonadIO m) => Handle -> a -> m ()
hGetChunk :: (IOData a, MonadIO m) => Handle -> m a
instance Data.IOData.IOData Data.ByteString.Internal.ByteString
instance Data.IOData.IOData Data.ByteString.Lazy.Internal.ByteString
instance Data.IOData.IOData Data.Text.Internal.Text
instance Data.IOData.IOData Data.Text.Internal.Lazy.Text
instance GHC.Types.Char ~ c => Data.IOData.IOData [c]


-- | Various zipping and unzipping functions for chunked data structures.
module Data.ChunkedZip
class Functor f => Zip f where zip = zipWith (,) zap = zipWith id unzip = fmap fst &&& fmap snd
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zip :: Zip f => f a -> f b -> f (a, b)
zap :: Zip f => f (a -> b) -> f a -> f b
unzip :: Zip f => f (a, b) -> (f a, f b)
class Functor f => Zip3 f where zip3 = zipWith3 (\ x y z -> (x, y, z)) zap3 = zipWith3 id
zipWith3 :: Zip3 f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d
zip3 :: Zip3 f => f a -> f b -> f c -> f (a, b, c)
zap3 :: Zip3 f => f (a -> b -> c) -> f a -> f b -> f c
unzip3 :: Zip3 f => f (a, b, c) -> (f a, f b, f c)
class Functor f => Zip4 f where zip4 = zipWith4 (\ w x y z -> (w, x, y, z)) zap4 = zipWith4 id
zipWith4 :: Zip4 f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
zip4 :: Zip4 f => f a -> f b -> f c -> f d -> f (a, b, c, d)
zap4 :: Zip4 f => f (a -> b -> c -> d) -> f a -> f b -> f c -> f d
unzip4 :: Zip4 f => f (a, b, c, d) -> (f a, f b, f c, f d)
class Functor f => Zip5 f where zip5 = zipWith5 (\ v w x y z -> (v, w, x, y, z)) zap5 = zipWith5 id
zipWith5 :: Zip5 f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
zip5 :: Zip5 f => f a -> f b -> f c -> f d -> f e -> f (a, b, c, d, e)
zap5 :: Zip5 f => f (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e
unzip5 :: Zip5 f => f (a, b, c, d, e) -> (f a, f b, f c, f d, f e)
class Functor f => Zip6 f where zip6 = zipWith6 (\ u v w x y z -> (u, v, w, x, y, z)) zap6 = zipWith6 id
zipWith6 :: Zip6 f => (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
zip6 :: Zip6 f => f a -> f b -> f c -> f d -> f e -> f g -> f (a, b, c, d, e, g)
zap6 :: Zip6 f => f (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g
unzip6 :: Zip6 f => f (a, b, c, d, e, g) -> (f a, f b, f c, f d, f e, f g)
class Functor f => Zip7 f where zip7 = zipWith7 (\ t u v w x y z -> (t, u, v, w, x, y, z)) zap7 = zipWith7 id
zipWith7 :: Zip7 f => (a -> b -> c -> d -> e -> g -> h -> i) -> f a -> f b -> f c -> f d -> f e -> f g -> f h -> f i
zip7 :: Zip7 f => f a -> f b -> f c -> f d -> f e -> f g -> f h -> f (a, b, c, d, e, g, h)
zap7 :: Zip7 f => f (a -> b -> c -> d -> e -> g -> h) -> f a -> f b -> f c -> f d -> f e -> f g -> f h
unzip7 :: Zip7 f => f (a, b, c, d, e, g, h) -> (f a, f b, f c, f d, f e, f g, f h)
instance Data.ChunkedZip.Zip []
instance Data.ChunkedZip.Zip Data.List.NonEmpty.NonEmpty
instance Data.ChunkedZip.Zip Data.Sequence.Seq
instance Data.ChunkedZip.Zip Data.Tree.Tree
instance Data.ChunkedZip.Zip Data.Vector.Vector
instance Data.ChunkedZip.Zip m => Data.ChunkedZip.Zip (Control.Monad.Trans.Identity.IdentityT m)
instance Data.ChunkedZip.Zip ((->) a)
instance Data.ChunkedZip.Zip m => Data.ChunkedZip.Zip (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.ChunkedZip.Zip Data.IntMap.Base.IntMap
instance (Data.ChunkedZip.Zip f, Data.ChunkedZip.Zip g) => Data.ChunkedZip.Zip (Data.Functor.Compose.Compose f g)
instance Data.ChunkedZip.Zip3 []
instance Data.ChunkedZip.Zip3 Data.Vector.Vector
instance Data.ChunkedZip.Zip3 Data.Sequence.Seq
instance Data.ChunkedZip.Zip4 []
instance Data.ChunkedZip.Zip4 Data.Vector.Vector
instance Data.ChunkedZip.Zip4 Data.Sequence.Seq
instance Data.ChunkedZip.Zip5 []
instance Data.ChunkedZip.Zip5 Data.Vector.Vector
instance Data.ChunkedZip.Zip6 []
instance Data.ChunkedZip.Zip6 Data.Vector.Vector
instance Data.ChunkedZip.Zip7 []


-- | Abstraction for different kinds of builders.
--   
--   Note that whenever a character encoding is used, it will be UTF8. For
--   different behavior, please use the underlying library.
module Data.Builder

-- | Since 0.1.0.0
type TextBuilder = Builder

-- | Since 0.1.0.0
type BlazeBuilder = Builder

-- | Since 0.1.0.0
class Monoid builder => Builder builder lazy | builder -> lazy, lazy -> builder

-- | Since 0.1.0.0
builderToLazy :: Builder builder lazy => builder -> lazy

-- | Since 0.1.0.0
flushBuilder :: Builder builder lazy => builder

-- | Since 0.1.0.0
class ToBuilder value builder

-- | Since 0.1.0.0
toBuilder :: ToBuilder value builder => value -> builder

-- | Provided for type disambiguation in the presence of OverloadedStrings.
--   
--   Since 0.1.0.0
textToBuilder :: ToBuilder Text builder => Text -> builder
instance Data.Builder.Builder Data.Text.Internal.Builder.Builder Data.Text.Internal.Lazy.Text
instance Data.Builder.Builder Data.ByteString.Builder.Internal.Builder Data.ByteString.Lazy.Internal.ByteString
instance Data.Builder.ToBuilder Data.Text.Internal.Builder.Builder Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Text Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Lazy.Text Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder GHC.Types.Char Data.Text.Internal.Builder.Builder
instance a ~ GHC.Types.Char => Data.Builder.ToBuilder [a] Data.Text.Internal.Builder.Builder
instance Data.Builder.ToBuilder Data.ByteString.Builder.Internal.Builder Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Text Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.Text.Internal.Lazy.Text Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder GHC.Types.Char Data.ByteString.Builder.Internal.Builder
instance a ~ GHC.Types.Char => Data.Builder.ToBuilder [a] Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.ByteString.Internal.ByteString Data.ByteString.Builder.Internal.Builder
instance Data.Builder.ToBuilder Data.ByteString.Lazy.Internal.ByteString Data.ByteString.Builder.Internal.Builder
