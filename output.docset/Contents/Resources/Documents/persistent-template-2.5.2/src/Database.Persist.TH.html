<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html xmlns="http://www.w3.org/1999/xhtml"><head><link rel="stylesheet" type="text/css" href="style.css"></link><script type="text/javascript" src="highlight.js"></script></head><body><pre><span class="hs-pragma">{-# LANGUAGE TemplateHaskell #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-2" name="line-2"></a><span class="hs-pragma">{-# LANGUAGE RecordWildCards #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-3" name="line-3"></a><span class="hs-pragma">{-# LANGUAGE CPP #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-4" name="line-4"></a><span class="hs-pragma">{-# LANGUAGE OverloadedStrings #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-5" name="line-5"></a><span class="hs-pragma">{-# LANGUAGE RankNTypes #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-6" name="line-6"></a><span class="hs-pragma">{-# LANGUAGE TupleSections #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-7" name="line-7"></a><span class="hs-pragma">{-# LANGUAGE FlexibleContexts, FlexibleInstances, MultiParamTypeClasses #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-8" name="line-8"></a><span class="hs-pragma">{-# LANGUAGE UndecidableInstances #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-9" name="line-9"></a><span class="hs-pragma">{-# OPTIONS_GHC -fno-warn-orphans -fno-warn-missing-fields #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-10" name="line-10"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-11" name="line-11"></a><span class="hs-cpp">#if !MIN_VERSION_base(4,8,0)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-12" name="line-12"></a><span class="hs-comment">-- overlapping instances is for automatic lifting</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-13" name="line-13"></a><span class="hs-comment">-- while avoiding an orphan of Lift for Text</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-14" name="line-14"></a><span class="hs-pragma">{-# LANGUAGE OverlappingInstances #-}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-15" name="line-15"></a><span class="hs-cpp">#endif</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-16" name="line-16"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-17" name="line-17"></a><span class="hs-comment">-- | This module provides utilities for creating backends. Regular users do not</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-18" name="line-18"></a><span class="hs-comment">-- need to use this module.</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-19" name="line-19"></a><span class="hs-keyword">module</span><span> </span><span class="hs-identifier">Database</span><span class="hs-operator">.</span><span class="hs-identifier">Persist</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-20" name="line-20"></a><span>    </span><span class="hs-special">(</span><span> </span><span class="hs-comment">-- * Parse entity defs</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-21" name="line-21"></a><span>      </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistWith"><span class="hs-identifier hs-var">persistWith</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-22" name="line-22"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistUpperCase"><span class="hs-identifier hs-var">persistUpperCase</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-23" name="line-23"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistLowerCase"><span class="hs-identifier hs-var">persistLowerCase</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-24" name="line-24"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistFileWith"><span class="hs-identifier hs-var">persistFileWith</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-25" name="line-25"></a><span>      </span><span class="hs-comment">-- * Turn @EntityDef@s into types</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-26" name="line-26"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mkPersist"><span class="hs-identifier hs-var">mkPersist</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-27" name="line-27"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#MkPersistSettings"><span class="hs-identifier hs-type">MkPersistSettings</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-28" name="line-28"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mpsBackend"><span class="hs-identifier hs-var">mpsBackend</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-29" name="line-29"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mpsGeneric"><span class="hs-identifier hs-var">mpsGeneric</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-30" name="line-30"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mpsPrefixFields"><span class="hs-identifier hs-var">mpsPrefixFields</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-31" name="line-31"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mpsEntityJSON"><span class="hs-identifier hs-var">mpsEntityJSON</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-32" name="line-32"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mpsGenerateLenses"><span class="hs-identifier hs-var">mpsGenerateLenses</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-33" name="line-33"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#EntityJSON"><span class="hs-identifier hs-type">EntityJSON</span></a><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-34" name="line-34"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mkPersistSettings"><span class="hs-identifier hs-var">mkPersistSettings</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-35" name="line-35"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#sqlSettings"><span class="hs-identifier hs-var">sqlSettings</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-36" name="line-36"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#sqlOnlySettings"><span class="hs-identifier hs-var">sqlOnlySettings</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-37" name="line-37"></a><span>      </span><span class="hs-comment">-- * Various other TH functions</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-38" name="line-38"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mkMigrate"><span class="hs-identifier hs-var">mkMigrate</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-39" name="line-39"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mkSave"><span class="hs-identifier hs-var">mkSave</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-40" name="line-40"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mkDeleteCascade"><span class="hs-identifier hs-var">mkDeleteCascade</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-41" name="line-41"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#share"><span class="hs-identifier hs-var">share</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-42" name="line-42"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#derivePersistField"><span class="hs-identifier hs-var">derivePersistField</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-43" name="line-43"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#derivePersistFieldJSON"><span class="hs-identifier hs-var">derivePersistFieldJSON</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-44" name="line-44"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistFieldFromEntity"><span class="hs-identifier hs-var">persistFieldFromEntity</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-45" name="line-45"></a><span>      </span><span class="hs-comment">-- * Internal</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-46" name="line-46"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#packPTH"><span class="hs-identifier hs-var">packPTH</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-47" name="line-47"></a><span>    </span><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#lensPTH"><span class="hs-identifier hs-var">lensPTH</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-48" name="line-48"></a><span>    </span><span class="hs-special">)</span><span> </span><span class="hs-keyword">where</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-49" name="line-49"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-50" name="line-50"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Prelude</span><span> </span><span class="hs-keyword">hiding</span><span> </span><span class="hs-special">(</span><span class="hs-special">(</span><span class="hs-operator hs-var">++</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">take</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">concat</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">splitAt</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">exp</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-51" name="line-51"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Database</span><span class="hs-operator">.</span><span class="hs-identifier">Persist</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-52" name="line-52"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Database</span><span class="hs-operator">.</span><span class="hs-identifier">Persist</span><span class="hs-operator">.</span><span class="hs-identifier">Sql</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Migration</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">migrate</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">SqlBackend</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">PersistFieldSql</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-53" name="line-53"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Database</span><span class="hs-operator">.</span><span class="hs-identifier">Persist</span><span class="hs-operator">.</span><span class="hs-identifier">Quasi</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-54" name="line-54"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language</span><span class="hs-operator">.</span><span class="hs-identifier">Haskell</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span class="hs-operator">.</span><span class="hs-identifier">Lib</span><span> </span><span class="hs-special">(</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-55" name="line-55"></a><span class="hs-cpp">#if MIN_VERSION_template_haskell(2,11,0)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-56" name="line-56"></a><span>    </span><span class="hs-identifier hs-var">conT</span><span class="hs-special">,</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-57" name="line-57"></a><span class="hs-cpp">#endif</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-58" name="line-58"></a><span>    </span><span class="hs-identifier hs-var">varE</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-59" name="line-59"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language</span><span class="hs-operator">.</span><span class="hs-identifier">Haskell</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span class="hs-operator">.</span><span class="hs-identifier">Quote</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-60" name="line-60"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Language</span><span class="hs-operator">.</span><span class="hs-identifier">Haskell</span><span class="hs-operator">.</span><span class="hs-identifier">TH</span><span class="hs-operator">.</span><span class="hs-identifier">Syntax</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-61" name="line-61"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Char</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">toLower</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">toUpper</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-62" name="line-62"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Monad</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">forM</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;=&lt;</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">mzero</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-63" name="line-63"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">System</span><span class="hs-operator">.</span><span class="hs-identifier">IO</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">SIO</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-64" name="line-64"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">pack</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Text</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">append</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">unpack</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">concat</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">uncons</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">cons</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">stripPrefix</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">stripSuffix</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-65" name="line-65"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Encoding</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">decodeUtf8</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-66" name="line-66"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">IO</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TIO</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-67" name="line-67"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Int</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Int64</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-68" name="line-68"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">List</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">foldl'</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-69" name="line-69"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Maybe</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">isJust</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">listToMaybe</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">mapMaybe</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">fromMaybe</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-70" name="line-70"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Monoid</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">mappend</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">mconcat</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-71" name="line-71"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Read</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">readPrec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">lexP</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">step</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">prec</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">parens</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Lexeme</span><span class="hs-special">(</span><span class="hs-identifier hs-var">Ident</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-72" name="line-72"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Map</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">M</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-73" name="line-73"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">HashMap</span><span class="hs-operator">.</span><span class="hs-identifier">Strict</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">HM</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-74" name="line-74"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Aeson</span><span class="hs-operator">.</span><span class="hs-identifier">Compat</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-75" name="line-75"></a><span>    </span><span class="hs-special">(</span><span> </span><span class="hs-identifier hs-type">ToJSON</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">toJSON</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">FromJSON</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">parseJSON</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">.=</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">object</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-76" name="line-76"></a><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">Value</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Object</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">.:</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">.:?</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-77" name="line-77"></a><span>    </span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">eitherDecodeStrict'</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-78" name="line-78"></a><span>    </span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-79" name="line-79"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Control</span><span class="hs-operator">.</span><span class="hs-identifier">Applicative</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">A</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">pure</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;$&gt;</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-special">(</span><span class="hs-operator hs-var">&lt;*&gt;</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-80" name="line-80"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Database</span><span class="hs-operator">.</span><span class="hs-identifier">Persist</span><span class="hs-operator">.</span><span class="hs-identifier">Sql</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">sqlType</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-81" name="line-81"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Proxy</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Proxy</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">Proxy</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-82" name="line-82"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Web</span><span class="hs-operator">.</span><span class="hs-identifier">PathPieces</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">PathPiece</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-83" name="line-83"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">Web</span><span class="hs-operator">.</span><span class="hs-identifier">HttpApiData</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">ToHttpApiData</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-type">FromHttpApiData</span><span class="hs-special">(</span><span class="hs-glyph">..</span><span class="hs-special">)</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-84" name="line-84"></a><span class="hs-keyword">import</span><span> </span><span class="hs-identifier">GHC</span><span class="hs-operator">.</span><span class="hs-identifier">Generics</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-type">Generic</span><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-85" name="line-85"></a><span class="hs-keyword">import</span><span> </span><span class="hs-keyword">qualified</span><span> </span><span class="hs-identifier">Data</span><span class="hs-operator">.</span><span class="hs-identifier">Text</span><span class="hs-operator">.</span><span class="hs-identifier">Encoding</span><span> </span><span class="hs-keyword">as</span><span> </span><span class="hs-identifier">TE</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-86" name="line-86"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-87" name="line-87"></a><span class="hs-comment">-- | This special-cases &quot;type_&quot; and strips out its underscore. When</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-88" name="line-88"></a><span class="hs-comment">-- used for JSON serialization and deserialization, it works around</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-89" name="line-89"></a><span class="hs-comment">-- &lt;https://github.com/yesodweb/persistent/issues/412&gt;</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-90" name="line-90"></a><span class="hs-identifier">unHaskellNameForJSON</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">HaskellName</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Text</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-91" name="line-91"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#unHaskellNameForJSON" name="unHaskellNameForJSON"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#unHaskellNameForJSON"><span class="hs-identifier">unHaskellNameForJSON</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058550"><span class="hs-identifier hs-var">fixTypeUnderscore</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier">unHaskellName</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-92" name="line-92"></a><span>  </span><span class="hs-keyword">where</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058550" name="local-6989586621679058550"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058550"><span class="hs-identifier">fixTypeUnderscore</span></a></a><span> </span><span class="hs-string">&quot;type&quot;</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-string">&quot;type_&quot;</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-93" name="line-93"></a><span>        </span><span class="hs-identifier">fixTypeUnderscore</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058551" name="local-6989586621679058551"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058551"><span class="hs-identifier">name</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058551"><span class="hs-identifier hs-var">name</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-94" name="line-94"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-95" name="line-95"></a><span class="hs-comment">-- | Converts a quasi-quoted syntax into a list of entity definitions, to be</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-96" name="line-96"></a><span class="hs-comment">-- used as input to the template haskell generation code (mkPersist).</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-97" name="line-97"></a><span class="hs-identifier">persistWith</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">PersistSettings</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">QuasiQuoter</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-98" name="line-98"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#persistWith" name="persistWith"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistWith"><span class="hs-identifier">persistWith</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058552" name="local-6989586621679058552"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058552"><span class="hs-identifier">ps</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">QuasiQuoter</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-99" name="line-99"></a><span>    </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">quoteExp</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#parseReferences"><span class="hs-identifier hs-var">parseReferences</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058552"><span class="hs-identifier hs-var">ps</span></a><span> </span><span class="hs-operator hs-var">.</span><span> </span><span class="hs-identifier hs-var">pack</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-100" name="line-100"></a><span>    </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-101" name="line-101"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-102" name="line-102"></a><span class="hs-comment">-- | Apply 'persistWith' to 'upperCaseSettings'.</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-103" name="line-103"></a><span class="hs-identifier">persistUpperCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">QuasiQuoter</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-104" name="line-104"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#persistUpperCase" name="persistUpperCase"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistUpperCase"><span class="hs-identifier">persistUpperCase</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistWith"><span class="hs-identifier hs-var">persistWith</span></a><span> </span><span class="hs-identifier hs-var">upperCaseSettings</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-105" name="line-105"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-106" name="line-106"></a><span class="hs-comment">-- | Apply 'persistWith' to 'lowerCaseSettings'.</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-107" name="line-107"></a><span class="hs-identifier">persistLowerCase</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">QuasiQuoter</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-108" name="line-108"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#persistLowerCase" name="persistLowerCase"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistLowerCase"><span class="hs-identifier">persistLowerCase</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistWith"><span class="hs-identifier hs-var">persistWith</span></a><span> </span><span class="hs-identifier hs-var">lowerCaseSettings</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-109" name="line-109"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-110" name="line-110"></a><span class="hs-comment">-- | Same as 'persistWith', but uses an external file instead of a</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-111" name="line-111"></a><span class="hs-comment">-- quasiquotation.</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-112" name="line-112"></a><span class="hs-identifier">persistFileWith</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">PersistSettings</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">FilePath</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Exp</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-113" name="line-113"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#persistFileWith" name="persistFileWith"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#persistFileWith"><span class="hs-identifier">persistFileWith</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058553" name="local-6989586621679058553"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058553"><span class="hs-identifier">ps</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058554" name="local-6989586621679058554"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058554"><span class="hs-identifier">fp</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">do</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-114" name="line-114"></a><span class="hs-cpp">#ifdef GHC_7_4</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-115" name="line-115"></a><span>    </span><span class="hs-identifier hs-var">qAddDependentFile</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058554"><span class="hs-identifier hs-var">fp</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-116" name="line-116"></a><span class="hs-cpp">#endif</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-117" name="line-117"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058830" name="local-6989586621679058830"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058830"><span class="hs-identifier">h</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">qRunIO</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">SIO</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">openFile</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058554"><span class="hs-identifier hs-var">fp</span></a><span> </span><span class="hs-identifier hs-var">SIO</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">ReadMode</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-118" name="line-118"></a><span>    </span><span class="hs-identifier hs-var">qRunIO</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">SIO</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">hSetEncoding</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058830"><span class="hs-identifier hs-var">h</span></a><span> </span><span class="hs-identifier hs-var">SIO</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">utf8_bom</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-119" name="line-119"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059186" name="local-6989586621679059186"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059186"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">&lt;-</span><span> </span><span class="hs-identifier hs-var">qRunIO</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">TIO</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">hGetContents</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058830"><span class="hs-identifier hs-var">h</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-120" name="line-120"></a><span>    </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#parseReferences"><span class="hs-identifier hs-var">parseReferences</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679058553"><span class="hs-identifier hs-var">ps</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059186"><span class="hs-identifier hs-var">s</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-121" name="line-121"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-122" name="line-122"></a><span class="hs-comment">-- calls parse to Quasi.parse individual entities in isolation</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-123" name="line-123"></a><span class="hs-comment">-- afterwards, sets references to other entities</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-124" name="line-124"></a><span class="hs-identifier">parseReferences</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">PersistSettings</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Text</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Q</span><span> </span><span class="hs-identifier hs-type">Exp</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-125" name="line-125"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#parseReferences" name="parseReferences"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#parseReferences"><span class="hs-identifier">parseReferences</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059187" name="local-6989586621679059187"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059187"><span class="hs-identifier">ps</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059188" name="local-6989586621679059188"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059188"><span class="hs-identifier">s</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">lift</span><span> </span><span class="hs-operator hs-var">$</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-126" name="line-126"></a><span>     </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#mkEntityDefSqlTypeExp"><span class="hs-identifier hs-var">mkEntityDefSqlTypeExp</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059191"><span class="hs-identifier hs-var">embedEntityMap</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059189"><span class="hs-identifier hs-var">entMap</span></a><span class="hs-special">)</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059190"><span class="hs-identifier hs-var">noCycleEnts</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-127" name="line-127"></a><span>  </span><span class="hs-keyword">where</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-128" name="line-128"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059189" name="local-6989586621679059189"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059189"><span class="hs-identifier">entMap</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">M</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">fromList</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059199" name="local-6989586621679059199"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059199"><span class="hs-identifier">ent</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">entityHaskell</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059199"><span class="hs-identifier hs-var">ent</span></a><span class="hs-special">,</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059199"><span class="hs-identifier hs-var">ent</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059190"><span class="hs-identifier hs-var">noCycleEnts</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-129" name="line-129"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059190" name="local-6989586621679059190"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059190"><span class="hs-identifier">noCycleEnts</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059195"><span class="hs-identifier hs-var">breakCycleEnt</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059192"><span class="hs-identifier hs-var">entsWithEmbeds</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-130" name="line-130"></a><span>    </span><span class="hs-comment">-- every EntityDef could reference each-other (as an EmbedRef)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-131" name="line-131"></a><span>    </span><span class="hs-comment">-- let Haskell tie the knot</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-132" name="line-132"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059191" name="local-6989586621679059191"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059191"><span class="hs-identifier">embedEntityMap</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">M</span><span class="hs-operator hs-var">.</span><span class="hs-identifier hs-var">fromList</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><span class="hs-glyph">\</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059200" name="local-6989586621679059200"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059200"><span class="hs-identifier">ent</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-special">(</span><span class="hs-identifier">entityHaskell</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059200"><span class="hs-identifier hs-var">ent</span></a><span class="hs-special">,</span><span> </span><span class="hs-identifier hs-var">toEmbedEntityDef</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059200"><span class="hs-identifier hs-var">ent</span></a><span class="hs-special">)</span><span class="hs-special">)</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059192"><span class="hs-identifier hs-var">entsWithEmbeds</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-133" name="line-133"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059192" name="local-6989586621679059192"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059192"><span class="hs-identifier">entsWithEmbeds</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059193"><span class="hs-identifier hs-var">setEmbedEntity</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059194"><span class="hs-identifier hs-var">rawEnts</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-134" name="line-134"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059193" name="local-6989586621679059193"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059193"><span class="hs-identifier">setEmbedEntity</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059201" name="local-6989586621679059201"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059201"><span class="hs-identifier">ent</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059201"><span class="hs-identifier hs-var">ent</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-135" name="line-135"></a><span>      </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">entityFields</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#setEmbedField"><span class="hs-identifier hs-var">setEmbedField</span></a><span> </span><span class="hs-special">(</span><span class="hs-identifier">entityHaskell</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059201"><span class="hs-identifier hs-var">ent</span></a><span class="hs-special">)</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059191"><span class="hs-identifier hs-var">embedEntityMap</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier">entityFields</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059201"><span class="hs-identifier hs-var">ent</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-136" name="line-136"></a><span>      </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-137" name="line-137"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059194" name="local-6989586621679059194"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059194"><span class="hs-identifier">rawEnts</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">parse</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059187"><span class="hs-identifier hs-var">ps</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059188"><span class="hs-identifier hs-var">s</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-138" name="line-138"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-139" name="line-139"></a><span>    </span><span class="hs-comment">-- self references are already broken</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-140" name="line-140"></a><span>    </span><span class="hs-comment">-- look at every emFieldEmbed to see if it refers to an already seen HaskellName</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-141" name="line-141"></a><span>    </span><span class="hs-comment">-- so start with entityHaskell ent and accumulate embeddedHaskell em</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-142" name="line-142"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059195" name="local-6989586621679059195"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059195"><span class="hs-identifier">breakCycleEnt</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059202" name="local-6989586621679059202"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059202"><span class="hs-identifier">entDef</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-143" name="line-143"></a><span>      </span><span class="hs-keyword">let</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059203" name="local-6989586621679059203"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059203"><span class="hs-identifier">entName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">entityHaskell</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059202"><span class="hs-identifier hs-var">entDef</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-144" name="line-144"></a><span>      </span><span class="hs-keyword">in</span><span>  </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059202"><span class="hs-identifier hs-var">entDef</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">entityFields</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059196"><span class="hs-identifier hs-var">breakCycleField</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059203"><span class="hs-identifier hs-var">entName</span></a><span class="hs-special">)</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><span class="hs-identifier">entityFields</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059202"><span class="hs-identifier hs-var">entDef</span></a><span> </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-145" name="line-145"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-146" name="line-146"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059196" name="local-6989586621679059196"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059196"><span class="hs-identifier">breakCycleField</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059204" name="local-6989586621679059204"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059204"><span class="hs-identifier">entName</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059205" name="local-6989586621679059205"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059205"><span class="hs-identifier">f</span></a></a><span class="hs-glyph">@</span><span class="hs-special">(</span><span class="hs-identifier hs-var">FieldDef</span><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">fieldReference</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">EmbedRef</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059206" name="local-6989586621679059206"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059206"><span class="hs-identifier">em</span></a></a><span> </span><span class="hs-special">}</span><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-147" name="line-147"></a><span>      </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059205"><span class="hs-identifier hs-var">f</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">fieldReference</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">EmbedRef</span><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059197"><span class="hs-identifier hs-var">breakCycleEmbed</span></a><span> </span><span class="hs-special">[</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059204"><span class="hs-identifier hs-var">entName</span></a><span class="hs-special">]</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059206"><span class="hs-identifier hs-var">em</span></a><span> </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-148" name="line-148"></a><span>    </span><span class="hs-identifier">breakCycleField</span><span> </span><span class="hs-identifier">_</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059207" name="local-6989586621679059207"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059207"><span class="hs-identifier">f</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059207"><span class="hs-identifier hs-var">f</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-149" name="line-149"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-150" name="line-150"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059197" name="local-6989586621679059197"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059197"><span class="hs-identifier">breakCycleEmbed</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059208" name="local-6989586621679059208"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059208"><span class="hs-identifier">ancestors</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059209" name="local-6989586621679059209"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059209"><span class="hs-identifier">em</span></a></a><span> </span><span class="hs-glyph">=</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-151" name="line-151"></a><span>        </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059209"><span class="hs-identifier hs-var">em</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">embeddedFields</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">map</span><span> </span><span class="hs-special">(</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059198"><span class="hs-identifier hs-var">breakCycleEmField</span></a><span> </span><span class="hs-operator hs-var">$</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059210"><span class="hs-identifier hs-var">emName</span></a><span> </span><span class="hs-glyph">:</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059208"><span class="hs-identifier hs-var">ancestors</span></a><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-152" name="line-152"></a><span>                                  </span><span class="hs-special">(</span><span class="hs-identifier">embeddedFields</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059209"><span class="hs-identifier hs-var">em</span></a><span class="hs-special">)</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-153" name="line-153"></a><span>           </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-154" name="line-154"></a><span>      </span><span class="hs-keyword">where</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-155" name="line-155"></a><span>        </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059210" name="local-6989586621679059210"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059210"><span class="hs-identifier">emName</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">embeddedHaskell</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059209"><span class="hs-identifier hs-var">em</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-156" name="line-156"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-157" name="line-157"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059198" name="local-6989586621679059198"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059198"><span class="hs-identifier">breakCycleEmField</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059211" name="local-6989586621679059211"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059211"><span class="hs-identifier">ancestors</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059212" name="local-6989586621679059212"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059212"><span class="hs-identifier">emf</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">embeddedHaskell</span><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059213"><span class="hs-identifier hs-var">membed</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-158" name="line-158"></a><span>        </span><span class="hs-identifier hs-var">Nothing</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059212"><span class="hs-identifier hs-var">emf</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-159" name="line-159"></a><span>        </span><span class="hs-identifier hs-var">Just</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059223" name="local-6989586621679059223"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059223"><span class="hs-identifier">embName</span></a></a><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-keyword">if</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059223"><span class="hs-identifier hs-var">embName</span></a><span> </span><span class="hs-special">`</span><span class="hs-identifier hs-var">elem</span><span class="hs-special">`</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059211"><span class="hs-identifier hs-var">ancestors</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-160" name="line-160"></a><span>          </span><span class="hs-keyword">then</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059212"><span class="hs-identifier hs-var">emf</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">emFieldEmbed</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span class="hs-special">,</span><span> </span><span class="hs-identifier">emFieldCycle</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059223"><span class="hs-identifier hs-var">embName</span></a><span> </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-161" name="line-161"></a><span>          </span><span class="hs-keyword">else</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059212"><span class="hs-identifier hs-var">emf</span></a><span> </span><span class="hs-special">{</span><span> </span><span class="hs-identifier">emFieldEmbed</span><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059197"><span class="hs-identifier hs-var">breakCycleEmbed</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059211"><span class="hs-identifier hs-var">ancestors</span></a><span> </span><span class="hs-operator hs-var">&lt;$&gt;</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059213"><span class="hs-identifier hs-var">membed</span></a><span> </span><span class="hs-special">}</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-162" name="line-162"></a><span>      </span><span class="hs-keyword">where</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-163" name="line-163"></a><span>        </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059213" name="local-6989586621679059213"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059213"><span class="hs-identifier">membed</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier">emFieldEmbed</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679059212"><span class="hs-identifier hs-var">emf</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-164" name="line-164"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-165" name="line-165"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-166" name="line-166"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-167" name="line-167"></a><span class="hs-identifier">stripId</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">FieldType</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">Text</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-168" name="line-168"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#stripId" name="stripId"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#stripId"><span class="hs-identifier">stripId</span></a></a><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">FTTypeCon</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060276" name="local-6989586621679060276"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060276"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">stripSuffix</span><span> </span><span class="hs-string">&quot;Id&quot;</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060276"><span class="hs-identifier hs-var">t</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-169" name="line-169"></a><span class="hs-identifier">stripId</span><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-170" name="line-170"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-171" name="line-171"></a><span class="hs-identifier">foreignReference</span><span> </span><span class="hs-glyph">::</span><span> </span><span class="hs-identifier hs-type">FieldDef</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-type">Maybe</span><span> </span><span class="hs-identifier hs-type">HaskellName</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-172" name="line-172"></a><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#foreignReference" name="foreignReference"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#foreignReference"><span class="hs-identifier">foreignReference</span></a></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060277" name="local-6989586621679060277"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060277"><span class="hs-identifier">field</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-keyword">case</span><span> </span><span class="hs-identifier">fieldReference</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060277"><span class="hs-identifier hs-var">field</span></a><span> </span><span class="hs-keyword">of</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-173" name="line-173"></a><span>    </span><span class="hs-identifier hs-var">ForeignRef</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060278" name="local-6989586621679060278"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060278"><span class="hs-identifier">ref</span></a></a><span> </span><span class="hs-identifier">_</span><span> </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Just</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679060278"><span class="hs-identifier hs-var">ref</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-174" name="line-174"></a><span>    </span><span class="hs-identifier">_</span><span>              </span><span class="hs-glyph">-&gt;</span><span> </span><span class="hs-identifier hs-var">Nothing</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-175" name="line-175"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-176" name="line-176"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-177" name="line-177"></a><span class="hs-comment">-- fieldSqlType at parse time can be an Exp</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-178" name="line-178"></a><span class="hs-comment">-- This helps delay setting fieldSqlType until lift time</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-179" name="line-179"></a><span class="hs-keyword">data</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#EntityDefSqlTypeExp" name="EntityDefSqlTypeExp"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#EntityDefSqlTypeExp"><span class="hs-identifier">EntityDefSqlTypeExp</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#EntityDefSqlTypeExp" name="EntityDefSqlTypeExp"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#EntityDefSqlTypeExp"><span class="hs-identifier">EntityDefSqlTypeExp</span></a></a><span> </span><span class="hs-identifier hs-type">EntityDef</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlTypeExp"><span class="hs-identifier hs-type">SqlTypeExp</span></a><span> </span><span class="hs-special">[</span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlTypeExp"><span class="hs-identifier hs-type">SqlTypeExp</span></a><span class="hs-special">]</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-180" name="line-180"></a><span>                           </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-identifier hs-type">Show</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-181" name="line-181"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-182" name="line-182"></a><span class="hs-keyword">data</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#SqlTypeExp" name="SqlTypeExp"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlTypeExp"><span class="hs-identifier">SqlTypeExp</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#SqlTypeExp" name="SqlTypeExp"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlTypeExp"><span class="hs-identifier">SqlTypeExp</span></a></a><span> </span><span class="hs-identifier hs-type">FieldType</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-183" name="line-183"></a><span>                </span><span class="hs-glyph">|</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#SqlType%27" name="SqlType%27"><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlType%27"><span class="hs-identifier">SqlType'</span></a></a><span> </span><span class="hs-identifier hs-type">SqlType</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-184" name="line-184"></a><span>                </span><span class="hs-keyword">deriving</span><span> </span><span class="hs-identifier hs-type">Show</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-185" name="line-185"></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-186" name="line-186"></a><span class="hs-keyword">instance</span><span> </span><span class="hs-identifier hs-type">Lift</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlTypeExp"><span class="hs-identifier hs-type">SqlTypeExp</span></a><span> </span><span class="hs-keyword">where</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-187" name="line-187"></a><span>    </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-3458764513820541131" name="local-3458764513820541131"><span class="hs-identifier">lift</span></a><span> </span><span class="hs-special">(</span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlType%27"><span class="hs-identifier hs-var">SqlType'</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077347" name="local-6989586621679077347"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077347"><span class="hs-identifier">t</span></a></a><span class="hs-special">)</span><span>       </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">lift</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077347"><span class="hs-identifier hs-var">t</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-188" name="line-188"></a><span>    </span><span class="hs-identifier">lift</span><span> </span><span class="hs-special">(</span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#SqlTypeExp"><span class="hs-identifier hs-var">SqlTypeExp</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077348" name="local-6989586621679077348"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077348"><span class="hs-identifier">ftype</span></a></a><span class="hs-special">)</span><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-identifier hs-var">return</span><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077352"><span class="hs-identifier hs-var">st</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-189" name="line-189"></a><span>      </span><span class="hs-keyword">where</span><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-190" name="line-190"></a><span>        </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077349" name="local-6989586621679077349"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077349"><span class="hs-identifier">typ</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><a href="../persistent-template-2.5.2/Database.Persist.TH.html#ftToType"><span class="hs-identifier hs-var">ftToType</span></a><span> </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077348"><span class="hs-identifier hs-var">ftype</span></a><span>
</span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#line-191" name="line-191"></a><span>        </span><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077350" name="local-6989586621679077350"><a href="../persistent-template-2.5.2/src/Database.Persist.TH.html#local-6989586621679077350"><span class="hs-identifier">mtyp</span></a></a><span> </span><span class="hs-glyph">=</span><span> </span><span class="hs-special">(</span><span class="hs-identifier hs-var">ConT</span><span> </span><span class="hs-char">''Proxy `AppT` typ)
        typedNothing = SigE (ConE 'Proxy) mtyp
        st = VarE 'sqlType `AppE` typedNothing

data FieldsSqlTypeExp = FieldsSqlTypeExp [FieldDef] [SqlTypeExp]

instance Lift FieldsSqlTypeExp where
    lift (FieldsSqlTypeExp fields sqlTypeExps) =
        lift $ zipWith FieldSqlTypeExp fields sqlTypeExps

data FieldSqlTypeExp = FieldSqlTypeExp FieldDef SqlTypeExp
instance Lift FieldSqlTypeExp where
    lift (FieldSqlTypeExp (FieldDef{..}) sqlTypeExp) =
      [|FieldDef fieldHaskell fieldDB fieldType $(lift sqlTypeExp) fieldAttrs fieldStrict fieldReference|]

instance Lift EntityDefSqlTypeExp where
    lift (EntityDefSqlTypeExp ent sqlTypeExp sqlTypeExps) =
        [|ent { entityFields = $(lift $ FieldsSqlTypeExp (entityFields ent) sqlTypeExps)
              , entityId = $(lift $ FieldSqlTypeExp (entityId ent) sqlTypeExp)
              }
        |]

instance Lift ReferenceDef where
    lift NoReference = [|NoReference|]
    lift (ForeignRef name ft) = [|ForeignRef name ft|]
    lift (EmbedRef em) = [|EmbedRef em|]
    lift (CompositeRef cdef) = [|CompositeRef cdef|]
    lift (SelfReference) = [|SelfReference|]

instance Lift EmbedEntityDef where
    lift (EmbedEntityDef name fields) = [|EmbedEntityDef name fields|]

instance Lift EmbedFieldDef where
    lift (EmbedFieldDef name em cyc) = [|EmbedFieldDef name em cyc|]

type EmbedEntityMap = M.Map HaskellName EmbedEntityDef
type EntityMap = M.Map HaskellName EntityDef

data FTTypeConDescr = FTKeyCon deriving Show
mEmbedded :: EmbedEntityMap -&gt; FieldType -&gt; Either (Maybe FTTypeConDescr) EmbedEntityDef
mEmbedded _ (FTTypeCon Just{} _) = Left Nothing
mEmbedded ents (FTTypeCon Nothing n) = let name = HaskellName n in
    maybe (Left Nothing) Right $ M.lookup name ents
mEmbedded ents (FTList x) = mEmbedded ents x
mEmbedded ents (FTApp x y) =
  -- Key converts an Record to a RecordId
  -- special casing this is obviously a hack
  -- This problem may not be solvable with the current QuasiQuoted approach though
  if x == FTTypeCon Nothing &quot;Key&quot;
    then Left $ Just FTKeyCon
    else mEmbedded ents y

setEmbedField :: HaskellName -&gt; EmbedEntityMap -&gt; FieldDef -&gt; FieldDef
setEmbedField entName allEntities field = field
  { fieldReference = case fieldReference field of
      NoReference -&gt;
        case mEmbedded allEntities (fieldType field) of
            Left _ -&gt; case stripId $ fieldType field of
                Nothing -&gt; NoReference
                Just name -&gt; case M.lookup (HaskellName name) allEntities of
                    Nothing -&gt; NoReference
                    Just _ -&gt; ForeignRef (HaskellName name)
                                    -- This can get corrected in mkEntityDefSqlTypeExp
                                    (FTTypeCon (Just &quot;Data.Int&quot;) &quot;Int64&quot;)
            Right em -&gt; if embeddedHaskell em /= entName
              then EmbedRef em
              else if maybeNullable field
                     then SelfReference
                     else case fieldType field of
                       FTList _ -&gt; SelfReference
                       _ -&gt; error $ unpack $ unHaskellName entName
                           `Data.Monoid.mappend` &quot;: a self reference must be a Maybe&quot;
      existing@_   -&gt; existing
  }

mkEntityDefSqlTypeExp :: EmbedEntityMap -&gt; EntityMap -&gt; EntityDef -&gt; EntityDefSqlTypeExp
mkEntityDefSqlTypeExp emEntities entMap ent = EntityDefSqlTypeExp ent
    (getSqlType $ entityId ent)
    $ (map getSqlType $ entityFields ent)
  where
    getSqlType field = maybe
        (defaultSqlTypeExp field)
        (SqlType' . SqlOther)
        (listToMaybe $ mapMaybe (stripPrefix &quot;sqltype=&quot;) $ fieldAttrs field)


    -- In the case of embedding, there won't be any datatype created yet.
    -- We just use SqlString, as the data will be serialized to JSON.
    defaultSqlTypeExp field = case mEmbedded emEntities ftype of
        Right _ -&gt; SqlType' SqlString
        Left (Just FTKeyCon) -&gt; SqlType' SqlString
        Left Nothing -&gt; case fieldReference field of
            ForeignRef refName ft  -&gt; case M.lookup refName entMap of
                Nothing  -&gt; SqlTypeExp ft
                -- A ForeignRef is blindly set to an Int64 in setEmbedField
                -- correct that now
                Just ent' -&gt; case entityPrimary ent' of
                    Nothing -&gt; SqlTypeExp ft
                    Just pdef -&gt; case compositeFields pdef of
                        [] -&gt; error &quot;mkEntityDefSqlTypeExp: no composite fields&quot;
                        [x] -&gt; SqlTypeExp $ fieldType x
                        _ -&gt; SqlType' $ SqlOther &quot;Composite Reference&quot;
            CompositeRef _  -&gt; SqlType' $ SqlOther &quot;Composite Reference&quot;
            _ -&gt; case ftype of
                    -- In the case of lists, we always serialize to a string
                    -- value (via JSON).
                    --
                    -- Normally, this would be determined automatically by
                    -- SqlTypeExp. However, there's one corner case: if there's
                    -- a list of entity IDs, the datatype for the ID has not
                    -- yet been created, so the compiler will fail. This extra
                    -- clause works around this limitation.
                    FTList _ -&gt; SqlType' SqlString
                    _ -&gt; SqlTypeExp ftype
      where
        ftype = fieldType field

-- | Create data types and appropriate 'PersistEntity' instances for the given
-- 'EntityDef's. Works well with the persist quasi-quoter.
mkPersist :: MkPersistSettings -&gt; [EntityDef] -&gt; Q [Dec]
mkPersist mps ents' = do
    x &lt;- fmap Data.Monoid.mconcat $ mapM (persistFieldFromEntity mps) ents
    y &lt;- fmap mconcat $ mapM (mkEntity entMap mps) ents
    z &lt;- fmap mconcat $ mapM (mkJSON mps) ents
    return $ mconcat [x, y, z]
  where
    ents = map fixEntityDef ents'
    entMap = M.fromList $ map (\ent -&gt; (entityHaskell ent, ent)) ents

-- | Implement special preprocessing on EntityDef as necessary for 'mkPersist'.
-- For example, strip out any fields marked as MigrationOnly.
fixEntityDef :: EntityDef -&gt; EntityDef
fixEntityDef ed =
    ed { entityFields = filter keepField $ entityFields ed }
  where
    keepField fd = &quot;MigrationOnly&quot; `notElem` fieldAttrs fd &amp;&amp;
                   &quot;SafeToRemove&quot; `notElem` fieldAttrs fd

-- | Settings to be passed to the 'mkPersist' function.
data MkPersistSettings = MkPersistSettings
    { mpsBackend :: Type
    -- ^ Which database backend we\'re using.
    --
    -- When generating data types, each type is given a generic version- which
    -- works with any backend- and a type synonym for the commonly used
    -- backend. This is where you specify that commonly used backend.
    , mpsGeneric :: Bool
    -- ^ Create generic types that can be used with multiple backends. Good for
    -- reusable code, but makes error messages harder to understand. Default:
    -- True.
    , mpsPrefixFields :: Bool
    -- ^ Prefix field names with the model name. Default: True.
    , mpsEntityJSON :: Maybe EntityJSON
    -- ^ Generate @ToJSON@/@FromJSON@ instances for each model types. If it's
    -- @Nothing@, no instances will be generated. Default:
    --
    -- @
    --  Just EntityJSON
    --      { entityToJSON = 'keyValueEntityToJSON
    --      , entityFromJSON = 'keyValueEntityFromJSON
    --      }
    -- @
    , mpsGenerateLenses :: !Bool
    -- ^ Instead of generating normal field accessors, generator lens-style accessors.
    --
    -- Default: False
    --
    -- Since 1.3.1
    }

data EntityJSON = EntityJSON
    { entityToJSON :: Name
    -- ^ Name of the @toJSON@ implementation for @Entity a@.
    , entityFromJSON :: Name
    -- ^ Name of the @fromJSON@ implementation for @Entity a@.
    }

-- | Create an @MkPersistSettings@ with default values.
mkPersistSettings :: Type -- ^ Value for 'mpsBackend'
                  -&gt; MkPersistSettings
mkPersistSettings t = MkPersistSettings
    { mpsBackend = t
    , mpsGeneric = False
    , mpsPrefixFields = True
    , mpsEntityJSON = Just EntityJSON
        { entityToJSON = 'entityIdToJSON
        , entityFromJSON = 'entityIdFromJSON
        }
    , mpsGenerateLenses = False
    }

-- | Use the 'SqlPersist' backend.
sqlSettings :: MkPersistSettings
sqlSettings = mkPersistSettings $ ConT ''SqlBackend

-- | Same as 'sqlSettings'.
--
-- Since 1.1.1
sqlOnlySettings :: MkPersistSettings
sqlOnlySettings = sqlSettings
{-# DEPRECATED sqlOnlySettings &quot;use sqlSettings&quot; #-}

recNameNoUnderscore :: MkPersistSettings -&gt; HaskellName -&gt; HaskellName -&gt; Text
recNameNoUnderscore mps dt f
  | mpsPrefixFields mps = lowerFirst (unHaskellName dt) ++ upperFirst ft
  | otherwise           = lowerFirst ft
  where ft = unHaskellName f

recName :: MkPersistSettings -&gt; HaskellName -&gt; HaskellName -&gt; Text
recName mps dt f =
    addUnderscore $ recNameNoUnderscore mps dt f
  where
    addUnderscore
        | mpsGenerateLenses mps = (&quot;_&quot; ++)
        | otherwise = id

lowerFirst :: Text -&gt; Text
lowerFirst t =
    case uncons t of
        Just (a, b) -&gt; cons (toLower a) b
        Nothing -&gt; t

upperFirst :: Text -&gt; Text
upperFirst t =
    case uncons t of
        Just (a, b) -&gt; cons (toUpper a) b
        Nothing -&gt; t

dataTypeDec :: MkPersistSettings -&gt; EntityDef -&gt; Q Dec
dataTypeDec mps t = do
    let names = map (mkName . unpack) $ entityDerives t
#if MIN_VERSION_template_haskell(2,12,0)
    DataD [] nameFinal paramsFinal
                Nothing
                constrs
                &lt;$&gt; fmap (pure . DerivClause Nothing) (mapM conT names)
#elif MIN_VERSION_template_haskell(2,11,0)
    DataD [] nameFinal paramsFinal
                Nothing
                constrs
                &lt;$&gt; mapM conT names
#else
    return $ DataD [] nameFinal paramsFinal constrs names
#endif
  where
    mkCol x fd@FieldDef {..} =
        (mkName $ unpack $ recName mps x fieldHaskell,
         if fieldStrict then isStrict else notStrict,
         maybeIdType mps fd Nothing Nothing
        )
    (nameFinal, paramsFinal)
        | mpsGeneric mps = (nameG, [PlainTV backend])
        | otherwise = (name, [])
    nameG = mkName $ unpack $ unHaskellName (entityHaskell t) ++ &quot;Generic&quot;
    name = mkName $ unpack $ unHaskellName $ entityHaskell t
    cols = map (mkCol $ entityHaskell t) $ entityFields t
    backend = backendName

    constrs
        | entitySum t = map sumCon $ entityFields t
        | otherwise = [RecC name cols]

    sumCon fd = NormalC
        (sumConstrName mps t fd)
        [(notStrict, maybeIdType mps fd Nothing Nothing)]

sumConstrName :: MkPersistSettings -&gt; EntityDef -&gt; FieldDef -&gt; Name
sumConstrName mps t FieldDef {..} = mkName $ unpack $ concat
    [ if mpsPrefixFields mps
        then unHaskellName $ entityHaskell t
        else &quot;&quot;
    , upperFirst $ unHaskellName fieldHaskell
    , &quot;Sum&quot;
    ]

uniqueTypeDec :: MkPersistSettings -&gt; EntityDef -&gt; Dec
uniqueTypeDec mps t =
    DataInstD [] ''Unique
        [genericDataType mps (entityHaskell t) backendT]
#if MIN_VERSION_template_haskell(2,11,0)
            Nothing
#endif
            (map (mkUnique mps t) $ entityUniques t)
            []

mkUnique :: MkPersistSettings -&gt; EntityDef -&gt; UniqueDef -&gt; Con
mkUnique mps t (UniqueDef (HaskellName constr) _ fields attrs) =
    NormalC (mkName $ unpack constr) types
  where
    types = map (go . flip lookup3 (entityFields t))
          $ map (unHaskellName . fst) fields

    force = &quot;!force&quot; `elem` attrs

    go :: (FieldDef, IsNullable) -&gt; (Strict, Type)
    go (_, Nullable _) | not force = error nullErrMsg
    go (fd, y) = (notStrict, maybeIdType mps fd Nothing (Just y))

    lookup3 :: Text -&gt; [FieldDef] -&gt; (FieldDef, IsNullable)
    lookup3 s [] =
        error $ unpack $ &quot;Column not found: &quot; ++ s ++ &quot; in unique &quot; ++ constr
    lookup3 x (fd@FieldDef {..}:rest)
        | x == unHaskellName fieldHaskell = (fd, nullable fieldAttrs)
        | otherwise = lookup3 x rest

    nullErrMsg =
      mconcat [ &quot;Error:  By default we disallow NULLables in an uniqueness &quot;
              , &quot;constraint.  The semantics of how NULL interacts with those &quot;
              , &quot;constraints is non-trivial:  two NULL values are not &quot;
              , &quot;considered equal for the purposes of an uniqueness &quot;
              , &quot;constraint.  If you understand this feature, it is possible &quot;
              , &quot;to use it your advantage.    *** Use a \&quot;!force\&quot; attribute &quot;
              , &quot;on the end of the line that defines your uniqueness &quot;
              , &quot;constraint in order to disable this check. ***&quot; ]

maybeIdType :: MkPersistSettings
           -&gt; FieldDef
           -&gt; Maybe Name -- ^ backend
           -&gt; Maybe IsNullable
           -&gt; Type
maybeIdType mps fd mbackend mnull = maybeTyp mayNullable idtyp
  where
    mayNullable = case mnull of
        (Just (Nullable ByMaybeAttr)) -&gt; True
        _ -&gt; maybeNullable fd
    idtyp = idType mps fd mbackend

backendDataType :: MkPersistSettings -&gt; Type
backendDataType mps
    | mpsGeneric mps = backendT
    | otherwise = mpsBackend mps

genericDataType :: MkPersistSettings
                -&gt; HaskellName -- ^ entity name
                -&gt; Type -- ^ backend
                -&gt; Type
genericDataType mps (HaskellName typ') backend
    | mpsGeneric mps = ConT (mkName $ unpack $ typ' ++ &quot;Generic&quot;) `AppT` backend
    | otherwise = ConT $ mkName $ unpack typ'

idType :: MkPersistSettings -&gt; FieldDef -&gt; Maybe Name -&gt; Type
idType mps fd mbackend =
    case foreignReference fd of
        Just typ -&gt;
            ConT ''Key
            `AppT` genericDataType mps typ (VarT $ fromMaybe backendName mbackend)
        Nothing -&gt; ftToType $ fieldType fd

degen :: [Clause] -&gt; [Clause]
degen [] =
    let err = VarE 'error `AppE` LitE (StringL
                &quot;Degenerate case, should never happen&quot;)
     in [normalClause [WildP] err]
degen x = x

mkToPersistFields :: MkPersistSettings -&gt; String -&gt; EntityDef -&gt; Q Dec
mkToPersistFields mps constr ed@EntityDef { entitySum = isSum, entityFields = fields } = do
    clauses &lt;-
        if isSum
            then sequence $ zipWith goSum fields [1..]
            else fmap return go
    return $ FunD 'toPersistFields clauses
  where
    go :: Q Clause
    go = do
        xs &lt;- sequence $ replicate fieldCount $ newName &quot;x&quot;
        let pat = ConP (mkName constr) $ map VarP xs
        sp &lt;- [|SomePersistField|]
        let bod = ListE $ map (AppE sp . VarE) xs
        return $ normalClause [pat] bod

    fieldCount = length fields

    goSum :: FieldDef -&gt; Int -&gt; Q Clause
    goSum fd idx = do
        let name = sumConstrName mps ed fd
        enull &lt;- [|SomePersistField PersistNull|]
        let beforeCount = idx - 1
            afterCount = fieldCount - idx
            before = replicate beforeCount enull
            after = replicate afterCount enull
        x &lt;- newName &quot;x&quot;
        sp &lt;- [|SomePersistField|]
        let body = ListE $ mconcat
                [ before
                , [sp `AppE` VarE x]
                , after
                ]
        return $ normalClause [ConP name [VarP x]] body


mkToFieldNames :: [UniqueDef] -&gt; Q Dec
mkToFieldNames pairs = do
    pairs' &lt;- mapM go pairs
    return $ FunD 'persistUniqueToFieldNames $ degen pairs'
  where
    go (UniqueDef constr _ names _) = do
        names' &lt;- lift names
        return $
            normalClause
                [RecP (mkName $ unpack $ unHaskellName constr) []]
                names'

mkUniqueToValues :: [UniqueDef] -&gt; Q Dec
mkUniqueToValues pairs = do
    pairs' &lt;- mapM go pairs
    return $ FunD 'persistUniqueToValues $ degen pairs'
  where
    go :: UniqueDef -&gt; Q Clause
    go (UniqueDef constr _ names _) = do
        xs &lt;- mapM (const $ newName &quot;x&quot;) names
        let pat = ConP (mkName $ unpack $ unHaskellName constr) $ map VarP xs
        tpv &lt;- [|toPersistValue|]
        let bod = ListE $ map (AppE tpv . VarE) xs
        return $ normalClause [pat] bod

isNotNull :: PersistValue -&gt; Bool
isNotNull PersistNull = False
isNotNull _ = True

mapLeft :: (a -&gt; c) -&gt; Either a b -&gt; Either c b
mapLeft _ (Right r) = Right r
mapLeft f (Left l)  = Left (f l)

fieldError :: Text -&gt; Text -&gt; Text
fieldError fieldName err = &quot;field &quot; `mappend` fieldName `mappend` &quot;: &quot; `mappend` err

mkFromPersistValues :: MkPersistSettings -&gt; EntityDef -&gt; Q [Clause]
mkFromPersistValues _ t@(EntityDef { entitySum = False }) =
    fromValues t &quot;fromPersistValues&quot; entE $ entityFields t
  where
    entE = ConE $ mkName $ unpack entName
    entName = unHaskellName $ entityHaskell t

mkFromPersistValues mps t@(EntityDef { entitySum = True }) = do
    nothing &lt;- [|Left (&quot;Invalid fromPersistValues input: sum type with all nulls. Entity: &quot; `mappend` entName)|]
    clauses &lt;- mkClauses [] $ entityFields t
    return $ clauses `mappend` [normalClause [WildP] nothing]
  where
    entName = unHaskellName $ entityHaskell t
    mkClauses _ [] = return []
    mkClauses before (field:after) = do
        x &lt;- newName &quot;x&quot;
        let null' = ConP 'PersistNull []
            pat = ListP $ mconcat
                [ map (const null') before
                , [VarP x]
                , map (const null') after
                ]
            constr = ConE $ sumConstrName mps t field
        fs &lt;- [|fromPersistValue $(return $ VarE x)|]
        let guard' = NormalG $ VarE 'isNotNull `AppE` VarE x
        let clause = Clause [pat] (GuardedB [(guard', InfixE (Just constr) fmapE (Just fs))]) []
        clauses &lt;- mkClauses (field : before) after
        return $ clause : clauses

type Lens s t a b = forall f. Functor f =&gt; (a -&gt; f b) -&gt; s -&gt; f t

lensPTH :: (s -&gt; a) -&gt; (s -&gt; b -&gt; t) -&gt; Lens s t a b
lensPTH sa sbt afb s = fmap (sbt s) (afb $ sa s)

fmapE :: Exp
fmapE = VarE 'fmap

mkLensClauses :: MkPersistSettings -&gt; EntityDef -&gt; Q [Clause]
mkLensClauses mps t = do
    lens' &lt;- [|lensPTH|]
    getId &lt;- [|entityKey|]
    setId &lt;- [|\(Entity _ value) key -&gt; Entity key value|]
    getVal &lt;- [|entityVal|]
    dot &lt;- [|(.)|]
    keyVar &lt;- newName &quot;key&quot;
    valName &lt;- newName &quot;value&quot;
    xName &lt;- newName &quot;x&quot;
    let idClause = normalClause
            [ConP (keyIdName t) []]
            (lens' `AppE` getId `AppE` setId)
    if entitySum t
        then return $ idClause : map (toSumClause lens' keyVar valName xName) (entityFields t)
        else return $ idClause : map (toClause lens' getVal dot keyVar valName xName) (entityFields t)
  where
    toClause lens' getVal dot keyVar valName xName f = normalClause
        [ConP (filterConName mps t f) []]
        (lens' `AppE` getter `AppE` setter)
      where
        fieldName = mkName $ unpack $ recName mps (entityHaskell t) (fieldHaskell f)
        getter = InfixE (Just $ VarE fieldName) dot (Just getVal)
        setter = LamE
            [ ConP 'Entity [VarP keyVar, VarP valName]
            , VarP xName
            ]
            $ ConE 'Entity `AppE` VarE keyVar `AppE` RecUpdE
                (VarE valName)
                [(fieldName, VarE xName)]

    toSumClause lens' keyVar valName xName f = normalClause
        [ConP (filterConName mps t f) []]
        (lens' `AppE` getter `AppE` setter)
      where
        emptyMatch = Match WildP (NormalB $ VarE 'error `AppE` LitE (StringL &quot;Tried to use fieldLens on a Sum type&quot;)) []
        getter = LamE
            [ ConP 'Entity [WildP, VarP valName]
            ] $ CaseE (VarE valName)
            $ Match (ConP (sumConstrName mps t f) [VarP xName]) (NormalB $ VarE xName) []

            -- FIXME It would be nice if the types expressed that the Field is
            -- a sum type and therefore could result in Maybe.
            : if length (entityFields t) &gt; 1 then [emptyMatch] else []
        setter = LamE
            [ ConP 'Entity [VarP keyVar, WildP]
            , VarP xName
            ]
            $ ConE 'Entity `AppE` VarE keyVar `AppE` (ConE (sumConstrName mps t f) `AppE` VarE xName)



-- | declare the key type and associated instances
-- @'PathPiece'@, @'ToHttpApiData'@ and @'FromHttpApiData'@ instances are only generated for a Key with one field
mkKeyTypeDec :: MkPersistSettings -&gt; EntityDef -&gt; Q (Dec, [Dec])
mkKeyTypeDec mps t = do
    (instDecs, i) &lt;-
      if mpsGeneric mps
        then if not useNewtype
               then do pfDec &lt;- pfInstD
                       return (pfDec, [''Generic])
               else do gi &lt;- genericNewtypeInstances
                       return (gi, [])
        else if not useNewtype
               then do pfDec &lt;- pfInstD
                       return (pfDec, [''Show, ''Read, ''Eq, ''Ord, ''Generic])
                else do
                    let allInstances = [''Show, ''Read, ''Eq, ''Ord, ''PathPiece, ''ToHttpApiData, ''FromHttpApiData, ''PersistField, ''PersistFieldSql, ''ToJSON, ''FromJSON]
                    if customKeyType
                      then return ([], allInstances)
                      else do
                        bi &lt;- backendKeyI
                        return (bi, allInstances)

#if MIN_VERSION_template_haskell(2,12,0)
    cxti &lt;- mapM conT i
    let kd = if useNewtype
               then NewtypeInstD [] k [recordType] Nothing dec [DerivClause Nothing cxti]
               else DataInstD    [] k [recordType] Nothing [dec] [DerivClause Nothing cxti]
#elif MIN_VERSION_template_haskell(2,11,0)
    cxti &lt;- mapM conT i
    let kd = if useNewtype
               then NewtypeInstD [] k [recordType] Nothing dec cxti
               else DataInstD    [] k [recordType] Nothing [dec] cxti
#else
    let kd = if useNewtype
               then NewtypeInstD [] k [recordType] dec i
               else DataInstD    [] k [recordType] [dec] i
#endif
    return (kd, instDecs)
  where
    keyConE = keyConExp t
    unKeyE = unKeyExp t
    dec = RecC (keyConName t) (keyFields mps t)
    k = ''Key
    recordType = genericDataType mps (entityHaskell t) backendT
    pfInstD = -- FIXME: generate a PersistMap instead of PersistList
      [d|instance PersistField (Key $(A.pure recordType)) where
            toPersistValue = PersistList . keyToValues
            fromPersistValue (PersistList l) = keyFromValues l
            fromPersistValue got = error $ &quot;fromPersistValue: expected PersistList, got: &quot; `mappend` show got
         instance PersistFieldSql (Key $(pure recordType)) where
            sqlType _ = SqlString
         instance ToJSON (Key $(pure recordType))
         instance FromJSON (Key $(pure recordType))
      |]

    keyStringL = StringL . keyString
    -- ghc 7.6 cannot parse the left arrow Ident $() &lt;- lexP
    keyPattern = BindS (ConP 'Ident [LitP $ keyStringL t])

    backendKeyGenericI =
        [d| instance PersistStore $(pure backendT) =&gt;
              ToBackendKey $(pure backendT) $(pure recordType) where
                toBackendKey   = $(return unKeyE)
                fromBackendKey = $(return keyConE)
        |]
    backendKeyI = let bdt = backendDataType mps in
        [d| instance ToBackendKey $(pure bdt) $(pure recordType) where
                toBackendKey   = $(return unKeyE)
                fromBackendKey = $(return keyConE)
        |]

    -- truly unfortunate that TH doesn't support standalone deriving
    -- https://ghc.haskell.org/trac/ghc/ticket/8100
    genericNewtypeInstances = do
      instances &lt;- [|lexP|] &gt;&gt;= \lexPE -&gt; [| step readPrec &gt;&gt;= return . ($(pure keyConE) )|] &gt;&gt;= \readE -&gt; do
        alwaysInstances &lt;-
          [d|instance Show (BackendKey $(pure backendT)) =&gt; Show (Key $(pure recordType)) where
              showsPrec i x = showParen (i &gt; app_prec) $
                (showString $ $(pure $ LitE $ keyStringL t) `mappend` &quot; &quot;) .
                showsPrec i ($(return unKeyE) x)
                where app_prec = (10::Int)
             instance Read (BackendKey $(pure backendT)) =&gt; Read (Key $(pure recordType)) where
                readPrec = parens $ (prec app_prec $ $(pure $ DoE [keyPattern lexPE, NoBindS readE]))
                  where app_prec = (10::Int)
             instance Eq (BackendKey $(pure backendT)) =&gt; Eq (Key $(pure recordType)) where
                x == y =
                    ($(return unKeyE) x) ==
                    ($(return unKeyE) y)
             instance Ord (BackendKey $(pure backendT)) =&gt; Ord (Key $(pure recordType)) where
                compare x y = compare
                    ($(return unKeyE) x)
                    ($(return unKeyE) y)
             instance ToHttpApiData (BackendKey $(pure backendT)) =&gt; ToHttpApiData (Key $(pure recordType)) where
                toUrlPiece = toUrlPiece . $(return unKeyE)
             instance FromHttpApiData (BackendKey $(pure backendT)) =&gt; FromHttpApiData(Key $(pure recordType)) where
                parseUrlPiece = fmap $(return keyConE) . parseUrlPiece
             instance PathPiece (BackendKey $(pure backendT)) =&gt; PathPiece (Key $(pure recordType)) where
                toPathPiece = toPathPiece . $(return unKeyE)
                fromPathPiece = fmap $(return keyConE) . fromPathPiece
             instance PersistField (BackendKey $(pure backendT)) =&gt; PersistField (Key $(pure recordType)) where
                toPersistValue = toPersistValue . $(return unKeyE)
                fromPersistValue = fmap $(return keyConE) . fromPersistValue
             instance PersistFieldSql (BackendKey $(pure backendT)) =&gt; PersistFieldSql (Key $(pure recordType)) where
                sqlType = sqlType . fmap $(return unKeyE)
             instance ToJSON (BackendKey $(pure backendT)) =&gt; ToJSON (Key $(pure recordType)) where
                toJSON = toJSON . $(return unKeyE)
             instance FromJSON (BackendKey $(pure backendT)) =&gt; FromJSON (Key $(pure recordType)) where
                parseJSON = fmap $(return keyConE) . parseJSON
              |]

        if customKeyType then return alwaysInstances
          else fmap (alwaysInstances `mappend`) backendKeyGenericI
      return instances

    useNewtype = pkNewtype mps t
    customKeyType = not (defaultIdType t) || not useNewtype || isJust (entityPrimary t)


keyIdName :: EntityDef -&gt; Name
keyIdName = mkName . unpack . keyIdText

keyIdText :: EntityDef -&gt; Text
keyIdText t = (unHaskellName $ entityHaskell t) `mappend` &quot;Id&quot;

unKeyName :: EntityDef -&gt; Name
unKeyName t = mkName $ &quot;un&quot; `mappend` keyString t

unKeyExp :: EntityDef -&gt; Exp
unKeyExp = VarE . unKeyName

backendT :: Type
backendT = VarT backendName

backendName :: Name
backendName = mkName &quot;backend&quot;

keyConName :: EntityDef -&gt; Name
keyConName t = mkName $ resolveConflict $ keyString t
  where
    resolveConflict kn = if conflict then kn `mappend` &quot;'&quot; else kn
    conflict = any ((== HaskellName &quot;key&quot;) . fieldHaskell) $ entityFields t

keyConExp :: EntityDef -&gt; Exp
keyConExp = ConE . keyConName

keyString :: EntityDef -&gt; String
keyString = unpack . keyText

keyText :: EntityDef -&gt; Text
keyText t = unHaskellName (entityHaskell t) ++ &quot;Key&quot;

pkNewtype :: MkPersistSettings -&gt; EntityDef -&gt; Bool
pkNewtype mps t = length (keyFields mps t) &lt; 2

defaultIdType :: EntityDef -&gt; Bool
defaultIdType t = fieldType (entityId t) == FTTypeCon Nothing (keyIdText t)

keyFields :: MkPersistSettings -&gt; EntityDef -&gt; [(Name, Strict, Type)]
keyFields mps t = case entityPrimary t of
  Just pdef -&gt; map primaryKeyVar $ (compositeFields pdef)
  Nothing   -&gt; if defaultIdType t
    then [idKeyVar backendKeyType]
    else [idKeyVar $ ftToType $ fieldType $ entityId t]
  where
    backendKeyType
        | mpsGeneric mps = ConT ''BackendKey `AppT` backendT
        | otherwise      = ConT ''BackendKey `AppT` mpsBackend mps
    idKeyVar ft = (unKeyName t, notStrict, ft)
    primaryKeyVar fd = ( keyFieldName mps t fd
                       , notStrict
                       , ftToType $ fieldType fd
                       )

keyFieldName :: MkPersistSettings -&gt; EntityDef -&gt; FieldDef -&gt; Name
keyFieldName mps t fd
  | pkNewtype mps t = unKeyName t
  | otherwise = mkName $ unpack
    $ lowerFirst (keyText t) `mappend` (unHaskellName $ fieldHaskell fd)

mkKeyToValues :: MkPersistSettings -&gt; EntityDef -&gt; Q Dec
mkKeyToValues mps t = do
    (p, e) &lt;- case entityPrimary t of
        Nothing  -&gt;
          ([],) A.&lt;$&gt; [|(:[]) . toPersistValue . $(return $ unKeyExp t)|]
        Just pdef -&gt;
          return $ toValuesPrimary pdef
    return $ FunD 'keyToValues $ return $ normalClause p e
  where
    toValuesPrimary pdef =
      ( [VarP recordName]
      , ListE $ map (\fd -&gt; VarE 'toPersistValue `AppE` (VarE (keyFieldName mps t fd) `AppE` VarE recordName)) $ compositeFields pdef
      )
    recordName = mkName &quot;record&quot;

normalClause :: [Pat] -&gt; Exp -&gt; Clause
normalClause p e = Clause p (NormalB e) []

mkKeyFromValues :: MkPersistSettings -&gt; EntityDef -&gt; Q Dec
mkKeyFromValues _mps t = do
    clauses &lt;- case entityPrimary t of
        Nothing  -&gt; do
            e &lt;- [|fmap $(return $ keyConE) . fromPersistValue . headNote|]
            return $ [normalClause [] e]
        Just pdef -&gt;
            fromValues t &quot;keyFromValues&quot; keyConE (compositeFields pdef)
    return $ FunD 'keyFromValues clauses
  where
    keyConE = keyConExp t

headNote :: [PersistValue] -&gt; PersistValue
headNote (x:[]) = x
headNote xs = error $ &quot;mkKeyFromValues: expected a list of one element, got: &quot;
  `mappend` show xs


fromValues :: EntityDef -&gt; Text -&gt; Exp -&gt; [FieldDef] -&gt; Q [Clause]
fromValues t funName conE fields = do
    x &lt;- newName &quot;x&quot;
    let funMsg = entityText t `mappend` &quot;: &quot; `mappend` funName `mappend` &quot; failed on: &quot;
    patternMatchFailure &lt;-
      [|Left $ mappend funMsg (pack $ show $(return $ VarE x))|]
    suc &lt;- patternSuccess fields
    return [ suc, normalClause [VarP x] patternMatchFailure ]
  where
    patternSuccess [] = do
      rightE &lt;- [|Right|]
      return $ normalClause [ListP []] (rightE `AppE` conE)
    patternSuccess fieldsNE = do
        x1 &lt;- newName &quot;x1&quot;
        restNames &lt;- mapM (\i -&gt; newName $ &quot;x&quot; `mappend` show i) [2..length fieldsNE]
        (fpv1:mkPersistValues) &lt;- mapM mkPvFromFd fieldsNE
        app1E &lt;- [|(&lt;$&gt;)|]
        let conApp = infixFromPersistValue app1E fpv1 conE x1
        applyE &lt;- [|(A.&lt;*&gt;)|]
        let applyFromPersistValue = infixFromPersistValue applyE

        return $ normalClause
            [ListP $ map VarP (x1:restNames)]
            (foldl' (\exp (name, fpv) -&gt; applyFromPersistValue fpv exp name) conApp (zip restNames mkPersistValues))
        where
          infixFromPersistValue applyE fpv exp name =
              UInfixE exp applyE (fpv `AppE` VarE name)
          mkPvFromFd = mkPersistValue . unHaskellName . fieldHaskell
          mkPersistValue fieldName = [|mapLeft (fieldError fieldName) . fromPersistValue|]


mkEntity :: EntityMap -&gt; MkPersistSettings -&gt; EntityDef -&gt; Q [Dec]
mkEntity entMap mps t = do
    t' &lt;- liftAndFixKeys entMap t
    let nameT = unHaskellName entName
    let nameS = unpack nameT
    let clazz = ConT ''PersistEntity `AppT` genDataType
    tpf &lt;- mkToPersistFields mps nameS t
    fpv &lt;- mkFromPersistValues mps t
    utv &lt;- mkUniqueToValues $ entityUniques t
    puk &lt;- mkUniqueKeys t
    fkc &lt;- mapM (mkForeignKeysComposite mps t) $ entityForeigns t

    let primaryField = entityId t

    fields &lt;- mapM (mkField mps t) $ primaryField : entityFields t
    toFieldNames &lt;- mkToFieldNames $ entityUniques t

    (keyTypeDec, keyInstanceDecs) &lt;- mkKeyTypeDec mps t
    keyToValues' &lt;- mkKeyToValues mps t
    keyFromValues' &lt;- mkKeyFromValues mps t

    let addSyn -- FIXME maybe remove this
            | mpsGeneric mps = (:) $
                TySynD (mkName nameS) [] $
                    genericDataType mps entName $ mpsBackend mps
            | otherwise = id

    lensClauses &lt;- mkLensClauses mps t

    lenses &lt;- mkLenses mps t
    let instanceConstraint = if not (mpsGeneric mps) then [] else
          [mkClassP ''PersistStore [backendT]]

    dtd &lt;- dataTypeDec mps t
    return $ addSyn $
       dtd : mconcat fkc `mappend`
      ([ TySynD (keyIdName t) [] $
            ConT ''Key `AppT` ConT (mkName nameS)
      , instanceD instanceConstraint clazz $
        [ uniqueTypeDec mps t
        , keyTypeDec
        , keyToValues'
        , keyFromValues'
        , FunD 'entityDef [normalClause [WildP] t']
        , tpf
        , FunD 'fromPersistValues fpv
        , toFieldNames
        , utv
        , puk
        , DataInstD
            []
            ''EntityField
            [ genDataType
            , VarT $ mkName &quot;typ&quot;
            ]
#if MIN_VERSION_template_haskell(2,11,0)
            Nothing
#endif
            (map fst fields)
            []
        , FunD 'persistFieldDef (map snd fields)
        , TySynInstD
            ''PersistEntityBackend
#if MIN_VERSION_template_haskell(2,9,0)
            (TySynEqn
               [genDataType]
               (backendDataType mps))
#else
            [genDataType]
            (backendDataType mps)
#endif
        , FunD 'persistIdField [normalClause [] (ConE $ keyIdName t)]
        , FunD 'fieldLens lensClauses
        ]
      ] `mappend` lenses) `mappend` keyInstanceDecs
  where
    genDataType = genericDataType mps entName backendT
    entName = entityHaskell t

entityText :: EntityDef -&gt; Text
entityText = unHaskellName . entityHaskell

mkLenses :: MkPersistSettings -&gt; EntityDef -&gt; Q [Dec]
mkLenses mps _ | not (mpsGenerateLenses mps) = return []
mkLenses _ ent | entitySum ent = return []
mkLenses mps ent = fmap mconcat $ forM (entityFields ent) $ \field -&gt; do
    let lensName' = recNameNoUnderscore mps (entityHaskell ent) (fieldHaskell field)
        lensName = mkName $ unpack lensName'
        fieldName = mkName $ unpack $ &quot;_&quot; ++ lensName'
    needleN &lt;- newName &quot;needle&quot;
    setterN &lt;- newName &quot;setter&quot;
    fN &lt;- newName &quot;f&quot;
    aN &lt;- newName &quot;a&quot;
    yN &lt;- newName &quot;y&quot;
    let needle = VarE needleN
        setter = VarE setterN
        f = VarE fN
        a = VarE aN
        y = VarE yN
        fT = mkName &quot;f&quot;
        -- FIXME if we want to get really fancy, then: if this field is the
        -- *only* Id field present, then set backend1 and backend2 to different
        -- values
        backend1 = backendName
        backend2 = backendName
        aT = maybeIdType mps field (Just backend1) Nothing
        bT = maybeIdType mps field (Just backend2) Nothing
        mkST backend = genericDataType mps (entityHaskell ent) (VarT backend)
        sT = mkST backend1
        tT = mkST backend2
        t1 `arrow` t2 = ArrowT `AppT` t1 `AppT` t2
        vars = PlainTV fT
             : (if mpsGeneric mps then [PlainTV backend1{-, PlainTV backend2-}] else [])
    return
        [ SigD lensName $ ForallT vars [mkClassP ''Functor [VarT fT]] $
            (aT `arrow` (VarT fT `AppT` bT)) `arrow`
            (sT `arrow` (VarT fT `AppT` tT))
        , FunD lensName $ return $ Clause
            [VarP fN, VarP aN]
            (NormalB $ fmapE
                `AppE` setter
                `AppE` (f `AppE` needle))
            [ FunD needleN [normalClause [] (VarE fieldName `AppE` a)]
            , FunD setterN $ return $ normalClause
                [VarP yN]
                (RecUpdE a
                    [ (fieldName, y)
                    ])
            ]
        ]

mkForeignKeysComposite :: MkPersistSettings -&gt; EntityDef -&gt; ForeignDef -&gt; Q [Dec]
mkForeignKeysComposite mps t ForeignDef {..} = do
   let fieldName f = mkName $ unpack $ recName mps (entityHaskell t) f
   let fname = fieldName foreignConstraintNameHaskell
   let reftableString = unpack $ unHaskellName $ foreignRefTableHaskell
   let reftableKeyName = mkName $ reftableString `mappend` &quot;Key&quot;
   let tablename = mkName $ unpack $ entityText t
   recordName &lt;- newName &quot;record&quot;

   let fldsE = map (\((foreignName, _),_) -&gt; VarE (fieldName $ foreignName)
                 `AppE` VarE recordName) foreignFields
   let mkKeyE = foldl' AppE (maybeExp foreignNullable $ ConE reftableKeyName) fldsE
   let fn = FunD fname [normalClause [VarP recordName] mkKeyE]

   let t2 = maybeTyp foreignNullable $ ConT ''Key `AppT` ConT (mkName reftableString)
   let sig = SigD fname $ (ArrowT `AppT` (ConT tablename)) `AppT` t2
   return [sig, fn]

maybeExp :: Bool -&gt; Exp -&gt; Exp
maybeExp may exp | may = fmapE `AppE` exp
                 | otherwise = exp
maybeTyp :: Bool -&gt; Type -&gt; Type
maybeTyp may typ | may = ConT ''Maybe `AppT` typ
                 | otherwise = typ



-- | produce code similar to the following:
--
-- @
--   instance PersistEntity e =&gt; PersistField e where
--      toPersistValue = PersistMap $ zip columNames (map toPersistValue . toPersistFields)
--      fromPersistValue (PersistMap o) =
--          let columns = HM.fromList o
--          in fromPersistValues $ map (\name -&gt;
--            case HM.lookup name columns of
--              Just v -&gt; v
--              Nothing -&gt; PersistNull
--      fromPersistValue x = Left $ &quot;Expected PersistMap, received: &quot; ++ show x
--      sqlType _ = SqlString
-- @
persistFieldFromEntity :: MkPersistSettings -&gt; EntityDef -&gt; Q [Dec]
persistFieldFromEntity mps e = do
    ss &lt;- [|SqlString|]
    obj &lt;- [|\ent -&gt; PersistMap $ zip (map pack columnNames) (map toPersistValue $ toPersistFields ent)|]
    fpv &lt;- [|\x -&gt; let columns = HM.fromList x
                    in fromPersistValues $ map
                         (\(name) -&gt;
                            case HM.lookup (pack name) columns of
                                Just v -&gt; v
                                Nothing -&gt; PersistNull)
                         $ columnNames
          |]

    compose &lt;- [|(&lt;=&lt;)|]
    getPersistMap' &lt;- [|getPersistMap|]
    return
        [ persistFieldInstanceD (mpsGeneric mps) typ
            [ FunD 'toPersistValue [ normalClause [] obj ]
            , FunD 'fromPersistValue
                [ normalClause [] (InfixE (Just fpv) compose $ Just getPersistMap')
                ]
            ]
        , persistFieldSqlInstanceD (mpsGeneric mps) typ
            [ sqlTypeFunD ss
            ]
        ]
    where
      typ = genericDataType mps (entityHaskell e) backendT
      entFields = entityFields e
      columnNames  = map (unpack . unHaskellName . fieldHaskell) entFields

-- | Apply the given list of functions to the same @EntityDef@s.
--
-- This function is useful for cases such as:
--
-- &gt;&gt;&gt; share [mkSave &quot;myDefs&quot;, mkPersist sqlSettings] [persistLowerCase|...|]
share :: [[EntityDef] -&gt; Q [Dec]] -&gt; [EntityDef] -&gt; Q [Dec]
share fs x = fmap mconcat $ mapM ($ x) fs

-- | Save the @EntityDef@s passed in under the given name.
mkSave :: String -&gt; [EntityDef] -&gt; Q [Dec]
mkSave name' defs' = do
    let name = mkName name'
    defs &lt;- lift defs'
    return [ SigD name $ ListT `AppT` ConT ''EntityDef
           , FunD name [normalClause [] defs]
           ]

data Dep = Dep
    { depTarget :: HaskellName
    , depSourceTable :: HaskellName
    , depSourceField :: HaskellName
    , depSourceNull  :: IsNullable
    }

-- | Generate a 'DeleteCascade' instance for the given @EntityDef@s.
mkDeleteCascade :: MkPersistSettings -&gt; [EntityDef] -&gt; Q [Dec]
mkDeleteCascade mps defs = do
    let deps = concatMap getDeps defs
    mapM (go deps) defs
  where
    getDeps :: EntityDef -&gt; [Dep]
    getDeps def =
        concatMap getDeps' $ entityFields $ fixEntityDef def
      where
        getDeps' :: FieldDef -&gt; [Dep]
        getDeps' field@FieldDef {..} =
            case foreignReference field of
                Just name -&gt;
                     return Dep
                        { depTarget = name
                        , depSourceTable = entityHaskell def
                        , depSourceField = fieldHaskell
                        , depSourceNull  = nullable fieldAttrs
                        }
                Nothing -&gt; []
    go :: [Dep] -&gt; EntityDef -&gt; Q Dec
    go allDeps EntityDef{entityHaskell = name} = do
        let deps = filter (\x -&gt; depTarget x == name) allDeps
        key &lt;- newName &quot;key&quot;
        let del = VarE 'delete
        let dcw = VarE 'deleteCascadeWhere
        just &lt;- [|Just|]
        filt &lt;- [|Filter|]
        eq &lt;- [|Eq|]
        left &lt;- [|Left|]
        let mkStmt :: Dep -&gt; Stmt
            mkStmt dep = NoBindS
                $ dcw `AppE`
                  ListE
                    [ filt `AppE` ConE filtName
                           `AppE` (left `AppE` val (depSourceNull dep))
                           `AppE` eq
                    ]
              where
                filtName = filterConName' mps (depSourceTable dep) (depSourceField dep)
                val (Nullable ByMaybeAttr) = just `AppE` VarE key
                val _                      =             VarE key



        let stmts :: [Stmt]
            stmts = map mkStmt deps `mappend`
                    [NoBindS $ del `AppE` VarE key]

        let entityT = genericDataType mps name backendT

        return $
            instanceD
            [ mkClassP ''PersistQuery [backendT]
            , mkEqualP (ConT ''PersistEntityBackend `AppT` entityT) (ConT ''BaseBackend `AppT` backendT)
            ]
            (ConT ''DeleteCascade `AppT` entityT `AppT` backendT)
            [ FunD 'deleteCascade
                [normalClause [VarP key] (DoE stmts)]
            ]

mkUniqueKeys :: EntityDef -&gt; Q Dec
mkUniqueKeys def | entitySum def =
    return $ FunD 'persistUniqueKeys [normalClause [WildP] (ListE [])]
mkUniqueKeys def = do
    c &lt;- clause
    return $ FunD 'persistUniqueKeys [c]
  where
    clause = do
        xs &lt;- forM (entityFields def) $ \fd -&gt; do
            let x = fieldHaskell fd
            x' &lt;- newName $ '_' : unpack (unHaskellName x)
            return (x, x')
        let pcs = map (go xs) $ entityUniques def
        let pat = ConP
                (mkName $ unpack $ unHaskellName $ entityHaskell def)
                (map (VarP . snd) xs)
        return $ normalClause [pat] (ListE pcs)

    go :: [(HaskellName, Name)] -&gt; UniqueDef -&gt; Exp
    go xs (UniqueDef name _ cols _) =
        foldl' (go' xs) (ConE (mkName $ unpack $ unHaskellName name)) (map fst cols)

    go' :: [(HaskellName, Name)] -&gt; Exp -&gt; HaskellName -&gt; Exp
    go' xs front col =
        let Just col' = lookup col xs
         in front `AppE` VarE col'

sqlTypeFunD :: Exp -&gt; Dec
sqlTypeFunD st = FunD 'sqlType
                [ normalClause [WildP] st ]

typeInstanceD :: Name
              -&gt; Bool -- ^ include PersistStore backend constraint
              -&gt; Type -&gt; [Dec] -&gt; Dec
typeInstanceD clazz hasBackend typ =
    instanceD ctx (ConT clazz `AppT` typ)
  where
    ctx
        | hasBackend = [mkClassP ''PersistStore [backendT]]
        | otherwise = []

persistFieldInstanceD :: Bool -- ^ include PersistStore backend constraint
                      -&gt; Type -&gt; [Dec] -&gt; Dec
persistFieldInstanceD = typeInstanceD ''PersistField

persistFieldSqlInstanceD :: Bool -- ^ include PersistStore backend constraint
                         -&gt; Type -&gt; [Dec] -&gt; Dec
persistFieldSqlInstanceD = typeInstanceD ''PersistFieldSql

-- | Automatically creates a valid 'PersistField' instance for any datatype
-- that has valid 'Show' and 'Read' instances. Can be very convenient for
-- 'Enum' types.
derivePersistField :: String -&gt; Q [Dec]
derivePersistField s = do
    ss &lt;- [|SqlString|]
    tpv &lt;- [|PersistText . pack . show|]
    fpv &lt;- [|\dt v -&gt;
                case fromPersistValue v of
                    Left e -&gt; Left e
                    Right s' -&gt;
                        case reads $ unpack s' of
                            (x, _):_ -&gt; Right x
                            [] -&gt; Left $ pack &quot;Invalid &quot; ++ pack dt ++ pack &quot;: &quot; ++ s'|]
    return
        [ persistFieldInstanceD False (ConT $ mkName s)
            [ FunD 'toPersistValue
                [ normalClause [] tpv
                ]
            , FunD 'fromPersistValue
                [ normalClause [] (fpv `AppE` LitE (StringL s))
                ]
            ]
        , persistFieldSqlInstanceD False (ConT $ mkName s)
            [ sqlTypeFunD ss
            ]
        ]

-- | Automatically creates a valid 'PersistField' instance for any datatype
-- that has valid 'ToJSON' and 'FromJSON' instances. For a datatype @T@ it
-- generates instances similar to these:
--
-- @
--    instance PersistField T where
--        toPersistValue = PersistByteString . L.toStrict . encode
--        fromPersistValue = (left T.pack) . eitherDecodeStrict' &lt;=&lt; fromPersistValue
--    instance PersistFieldSql T where
--        sqlType _ = SqlString
-- @
derivePersistFieldJSON :: String -&gt; Q [Dec]
derivePersistFieldJSON s = do
    ss &lt;- [|SqlString|]
    tpv &lt;- [|PersistText . toJsonText|]
    fpv &lt;- [|\dt v -&gt; do
                text &lt;- fromPersistValue v
                let bs' = TE.encodeUtf8 text
                case eitherDecodeStrict' bs' of
                    Left e -&gt; Left $ pack &quot;JSON decoding error for &quot; ++ pack dt ++ pack &quot;: &quot; ++ pack e ++ pack &quot;. On Input: &quot; ++ decodeUtf8 bs'
                    Right x -&gt; Right x|]
    return
        [ persistFieldInstanceD False (ConT $ mkName s)
            [ FunD 'toPersistValue
                [ normalClause [] tpv
                ]
            , FunD 'fromPersistValue
                [ normalClause [] (fpv `AppE` LitE (StringL s))
                ]
            ]
        , persistFieldSqlInstanceD False (ConT $ mkName s)
            [ sqlTypeFunD ss
            ]
        ]

-- | Creates a single function to perform all migrations for the entities
-- defined here. One thing to be aware of is dependencies: if you have entities
-- with foreign references, make sure to place those definitions after the
-- entities they reference.
mkMigrate :: String -&gt; [EntityDef] -&gt; Q [Dec]
mkMigrate fun allDefs = do
    body' &lt;- body
    return
        [ SigD (mkName fun) typ
        , FunD (mkName fun) [normalClause [] body']
        ]
  where
    defs = filter isMigrated allDefs
    isMigrated def = not $ &quot;no-migrate&quot; `elem` entityAttrs def
    typ = ConT ''Migration
    entMap = M.fromList $ map (\ent -&gt; (entityHaskell ent, ent)) allDefs
    body :: Q Exp
    body =
        case defs of
            [] -&gt; [|return ()|]
            _  -&gt; do
              defsName &lt;- newName &quot;defs&quot;
              defsStmt &lt;- do
                defs' &lt;- mapM (liftAndFixKeys entMap) defs
                let defsExp = ListE defs'
                return $ LetS [ValD (VarP defsName) (NormalB defsExp) []]
              stmts &lt;- mapM (toStmt $ VarE defsName) defs
              return (DoE $ defsStmt : stmts)
    toStmt :: Exp -&gt; EntityDef -&gt; Q Stmt
    toStmt defsExp ed = do
        u &lt;- liftAndFixKeys entMap ed
        m &lt;- [|migrate|]
        return $ NoBindS $ m `AppE` defsExp `AppE` u

liftAndFixKeys :: EntityMap -&gt; EntityDef -&gt; Q Exp
liftAndFixKeys entMap EntityDef{..} =
  [|EntityDef
      entityHaskell
      entityDB
      entityId
      entityAttrs
      $(ListE &lt;$&gt; mapM (liftAndFixKey entMap) entityFields)
      entityUniques
      entityForeigns
      entityDerives
      entityExtra
      entitySum
   |]

liftAndFixKey :: EntityMap -&gt; FieldDef -&gt; Q Exp
liftAndFixKey entMap (FieldDef a b c sqlTyp e f fieldRef) =
  [|FieldDef a b c $(sqlTyp') e f fieldRef'|]
  where
    (fieldRef', sqlTyp') = fromMaybe (fieldRef, lift sqlTyp) $
      case fieldRef of
        ForeignRef refName _ft -&gt; case M.lookup refName entMap of
          Nothing -&gt; Nothing
          Just ent -&gt;
            case fieldReference $ entityId ent of
              fr@(ForeignRef _Name ft) -&gt; Just (fr, lift $ SqlTypeExp ft)
              _ -&gt; Nothing
        _ -&gt; Nothing

instance Lift EntityDef where
    lift EntityDef{..} =
        [|EntityDef
            entityHaskell
            entityDB
            entityId
            entityAttrs
            entityFields
            entityUniques
            entityForeigns
            entityDerives
            entityExtra
            entitySum
            |]
instance Lift FieldDef where
    lift (FieldDef a b c d e f g) = [|FieldDef a b c d e f g|]
instance Lift UniqueDef where
    lift (UniqueDef a b c d) = [|UniqueDef a b c d|]
instance Lift CompositeDef where
    lift (CompositeDef a b) = [|CompositeDef a b|]
instance Lift ForeignDef where
    lift (ForeignDef a b c d e f g) = [|ForeignDef a b c d e f g|]

-- | A hack to avoid orphans.
class Lift' a where
    lift' :: a -&gt; Q Exp
instance Lift' Text where
    lift' = liftT
instance Lift' a =&gt; Lift' [a] where
    lift' xs = do { xs' &lt;- mapM lift' xs; return (ListE xs') }
instance (Lift' k, Lift' v) =&gt; Lift' (M.Map k v) where
    lift' m = [|M.fromList $(fmap ListE $ mapM liftPair $ M.toList m)|]

-- auto-lifting, means instances are overlapping
#if MIN_VERSION_base(4,8,0)
instance {-# OVERLAPPABLE #-} Lift' a =&gt; Lift a where
#else
instance Lift' a =&gt; Lift a where
#endif
    lift = lift'

packPTH :: String -&gt; Text
packPTH = pack
#if !MIN_VERSION_text(0, 11, 2)
{-# NOINLINE packPTH #-}
#endif

liftT :: Text -&gt; Q Exp
liftT t = [|packPTH $(lift (unpack t))|]

liftPair :: (Lift' k, Lift' v) =&gt; (k, v) -&gt; Q Exp
liftPair (k, v) = [|($(lift' k), $(lift' v))|]

instance Lift HaskellName where
    lift (HaskellName t) = [|HaskellName t|]
instance Lift DBName where
    lift (DBName t) = [|DBName t|]
instance Lift FieldType where
    lift (FTTypeCon Nothing t)  = [|FTTypeCon Nothing t|]
    lift (FTTypeCon (Just x) t) = [|FTTypeCon (Just x) t|]
    lift (FTApp x y) = [|FTApp x y|]
    lift (FTList x) = [|FTList x|]

instance Lift PersistFilter where
    lift Eq = [|Eq|]
    lift Ne = [|Ne|]
    lift Gt = [|Gt|]
    lift Lt = [|Lt|]
    lift Ge = [|Ge|]
    lift Le = [|Le|]
    lift In = [|In|]
    lift NotIn = [|NotIn|]
    lift (BackendSpecificFilter x) = [|BackendSpecificFilter x|]

instance Lift PersistUpdate where
    lift Assign = [|Assign|]
    lift Add = [|Add|]
    lift Subtract = [|Subtract|]
    lift Multiply = [|Multiply|]
    lift Divide = [|Divide|]
    lift (BackendSpecificUpdate x) = [|BackendSpecificUpdate x|]

instance Lift SqlType where
    lift SqlString = [|SqlString|]
    lift SqlInt32 = [|SqlInt32|]
    lift SqlInt64 = [|SqlInt64|]
    lift SqlReal = [|SqlReal|]
    lift (SqlNumeric x y) =
        [|SqlNumeric (fromInteger x') (fromInteger y')|]
      where
        x' = fromIntegral x :: Integer
        y' = fromIntegral y :: Integer
    lift SqlBool = [|SqlBool|]
    lift SqlDay = [|SqlDay|]
    lift SqlTime = [|SqlTime|]
    lift SqlDayTime = [|SqlDayTime|]
    lift SqlBlob = [|SqlBlob|]
    lift (SqlOther a) = [|SqlOther a|]

-- Ent
--   fieldName FieldType
--
-- forall . typ ~ FieldType =&gt; EntFieldName
--
-- EntFieldName = FieldDef ....
mkField :: MkPersistSettings -&gt; EntityDef -&gt; FieldDef -&gt; Q (Con, Clause)
mkField mps et cd = do
    let con = ForallC
                []
                [mkEqualP (VarT $ mkName &quot;typ&quot;) $ maybeIdType mps cd Nothing Nothing]
                $ NormalC name []
    bod &lt;- lift cd
    let cla = normalClause
                [ConP name []]
                bod
    return (con, cla)
  where
    name = filterConName mps et cd

maybeNullable :: FieldDef -&gt; Bool
maybeNullable fd = nullable (fieldAttrs fd) == Nullable ByMaybeAttr

filterConName :: MkPersistSettings
              -&gt; EntityDef
              -&gt; FieldDef
              -&gt; Name
filterConName mps entity field = filterConName' mps (entityHaskell entity) (fieldHaskell field)

filterConName' :: MkPersistSettings
               -&gt; HaskellName -- ^ table
               -&gt; HaskellName -- ^ field
               -&gt; Name
filterConName' mps entity field = mkName $ unpack $ concat
    [ if mpsPrefixFields mps || field == HaskellName &quot;Id&quot;
        then unHaskellName entity
        else &quot;&quot;
    , upperFirst $ unHaskellName field
    ]

ftToType :: FieldType -&gt; Type
ftToType (FTTypeCon Nothing t) = ConT $ mkName $ unpack t
-- This type is generated from the Quasi-Quoter.
-- Adding this special case avoids users needing to import Data.Int
ftToType (FTTypeCon (Just &quot;Data.Int&quot;) &quot;Int64&quot;) = ConT ''Int64
ftToType (FTTypeCon (Just m) t) = ConT $ mkName $ unpack $ concat [m, &quot;.&quot;, t]
ftToType (FTApp x y) = ftToType x `AppT` ftToType y
ftToType (FTList x) = ListT `AppT` ftToType x

infixr 5 ++
(++) :: Text -&gt; Text -&gt; Text
(++) = append

mkJSON :: MkPersistSettings -&gt; EntityDef -&gt; Q [Dec]
mkJSON _ def | not (&quot;json&quot; `elem` entityAttrs def) = return []
mkJSON mps def = do
    pureE &lt;- [|pure|]
    apE' &lt;- [|(&lt;*&gt;)|]
    packE &lt;- [|pack|]
    dotEqualE &lt;- [|(.=)|]
    dotColonE &lt;- [|(.:)|]
    dotColonQE &lt;- [|(.:?)|]
    objectE &lt;- [|object|]
    obj &lt;- newName &quot;obj&quot;
    mzeroE &lt;- [|mzero|]

    xs &lt;- mapM (newName . unpack . unHaskellNameForJSON . fieldHaskell)
        $ entityFields def

    let conName = mkName $ unpack $ unHaskellName $ entityHaskell def
        typ = genericDataType mps (entityHaskell def) backendT
        toJSONI = typeInstanceD ''ToJSON (mpsGeneric mps) typ [toJSON']
        toJSON' = FunD 'toJSON $ return $ normalClause
            [ConP conName $ map VarP xs]
            (objectE `AppE` ListE pairs)
        pairs = zipWith toPair (entityFields def) xs
        toPair f x = InfixE
            (Just (packE `AppE` LitE (StringL $ unpack $ unHaskellName $ fieldHaskell f)))
            dotEqualE
            (Just $ VarE x)
        fromJSONI = typeInstanceD ''FromJSON (mpsGeneric mps) typ [parseJSON']
        parseJSON' = FunD 'parseJSON
            [ normalClause [ConP 'Object [VarP obj]]
                (foldl'
                    (\x y -&gt; InfixE (Just x) apE' (Just y))
                    (pureE `AppE` ConE conName)
                    pulls
                )
            , normalClause [WildP] mzeroE
            ]
        pulls = map toPull $ entityFields def
        toPull f = InfixE
            (Just $ VarE obj)
            (if maybeNullable f then dotColonQE else dotColonE)
            (Just $ AppE packE $ LitE $ StringL $ unpack $ unHaskellName $ fieldHaskell f)
    case mpsEntityJSON mps of
        Nothing -&gt; return [toJSONI, fromJSONI]
        Just entityJSON -&gt; do
            entityJSONIs &lt;- if mpsGeneric mps
              then [d|
#if MIN_VERSION_base(4, 6, 0)
                instance PersistStore $(pure backendT) =&gt; ToJSON (Entity $(pure typ)) where
                    toJSON = $(varE (entityToJSON entityJSON))
                instance PersistStore $(pure backendT) =&gt; FromJSON (Entity $(pure typ)) where
                    parseJSON = $(varE (entityFromJSON entityJSON))
#endif
                |]
              else [d|
                instance ToJSON (Entity $(pure typ)) where
                    toJSON = $(varE (entityToJSON entityJSON))
                instance FromJSON (Entity $(pure typ)) where
                    parseJSON = $(varE (entityFromJSON entityJSON))
                |]
            return $ toJSONI : fromJSONI : entityJSONIs

mkClassP :: Name -&gt; [Type] -&gt; Pred
#if MIN_VERSION_template_haskell(2,10,0)
mkClassP cla tys = foldl AppT (ConT cla) tys
#else
mkClassP = ClassP
#endif

mkEqualP :: Type -&gt; Type -&gt; Pred
#if MIN_VERSION_template_haskell(2,10,0)
mkEqualP tleft tright = foldl AppT EqualityT [tleft, tright]
#else
mkEqualP = EqualP
#endif

#if MIN_VERSION_template_haskell(2,11,0)
notStrict :: Bang
notStrict = Bang NoSourceUnpackedness NoSourceStrictness

isStrict :: Bang
isStrict = Bang NoSourceUnpackedness SourceStrict
#else
notStrict :: Strict
notStrict = NotStrict

isStrict :: Strict
isStrict = IsStrict
#endif

instanceD :: Cxt -&gt; Type -&gt; [Dec] -&gt; Dec
#if MIN_VERSION_template_haskell(2,11,0)
instanceD = InstanceD Nothing
#else
instanceD = InstanceD
#endif

-- entityUpdates :: EntityDef -&gt; [(HaskellName, FieldType, IsNullable, PersistUpdate)]
-- entityUpdates =
--     concatMap go . entityFields
--   where
--     go FieldDef {..} = map (\a -&gt; (fieldHaskell, fieldType, nullable fieldAttrs, a)) [minBound..maxBound]

-- mkToUpdate :: String -&gt; [(String, PersistUpdate)] -&gt; Q Dec
-- mkToUpdate name pairs = do
--     pairs' &lt;- mapM go pairs
--     return $ FunD (mkName name) $ degen pairs'
--   where
--     go (constr, pu) = do
--         pu' &lt;- lift pu
--         return $ normalClause [RecP (mkName constr) []] pu'


-- mkToFieldName :: String -&gt; [(String, String)] -&gt; Dec
-- mkToFieldName func pairs =
--         FunD (mkName func) $ degen $ map go pairs
--   where
--     go (constr, name) =
--         normalClause [RecP (mkName constr) []] (LitE $ StringL name)

-- mkToValue :: String -&gt; [String] -&gt; Dec
-- mkToValue func = FunD (mkName func) . degen . map go
--   where
--     go constr =
--         let x = mkName &quot;x&quot;
--          in normalClause [ConP (mkName constr) [VarP x]]
--                    (VarE 'toPersistValue `AppE` VarE x)
</span></pre></body></html>