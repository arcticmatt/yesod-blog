-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Type-safe, multi-backend data serialization.
--   
--   Hackage documentation generation is not reliable. For up to date
--   documentation, please see:
--   <a>http://www.stackage.org/package/persistent</a>.
@package persistent
@version 2.6.1

module Database.Persist.Types

-- | A <a>Checkmark</a> should be used as a field type whenever a
--   uniqueness constraint should guarantee that a certain kind of record
--   may appear at most once, but other kinds of records may appear any
--   number of times.
--   
--   <i>NOTE:</i> You need to mark any <tt>Checkmark</tt> fields as
--   <tt>nullable</tt> (see the following example).
--   
--   For example, suppose there's a <tt>Location</tt> entity that
--   represents where a user has lived:
--   
--   <pre>
--   Location
--       user    UserId
--       name    Text
--       current Checkmark nullable
--   
--       UniqueLocation user current
--   </pre>
--   
--   The <tt>UniqueLocation</tt> constraint allows any number of
--   <a>Inactive</a> <tt>Location</tt>s to be <tt>current</tt>. However,
--   there may be at most one <tt>current</tt> <tt>Location</tt> per user
--   (i.e., either zero or one per user).
--   
--   This data type works because of the way that SQL treats
--   <tt>NULL</tt>able fields within uniqueness constraints. The SQL
--   standard says that <tt>NULL</tt> values should be considered
--   different, so we represent <a>Inactive</a> as SQL <tt>NULL</tt>, thus
--   allowing any number of <a>Inactive</a> records. On the other hand, we
--   represent <a>Active</a> as <tt>TRUE</tt>, so the uniqueness constraint
--   will disallow more than one <a>Active</a> record.
--   
--   <i>Note:</i> There may be DBMSs that do not respect the SQL standard's
--   treatment of <tt>NULL</tt> values on uniqueness constraints, please
--   check if this data type works before relying on it.
--   
--   The SQL <tt>BOOLEAN</tt> type is used because it's the smallest data
--   type available. Note that we never use <tt>FALSE</tt>, just
--   <tt>TRUE</tt> and <tt>NULL</tt>. Provides the same behavior <tt>Maybe
--   ()</tt> would if <tt>()</tt> was a valid <tt>PersistField</tt>.
data Checkmark

-- | When used on a uniqueness constraint, there may be at most one
--   <a>Active</a> record.
Active :: Checkmark

-- | When used on a uniqueness constraint, there may be any number of
--   <a>Inactive</a> records.
Inactive :: Checkmark
data IsNullable
Nullable :: !WhyNullable -> IsNullable
NotNullable :: IsNullable

-- | The reason why a field is <tt>nullable</tt> is very important. A field
--   that is nullable because of a <tt>Maybe</tt> tag will have its type
--   changed from <tt>A</tt> to <tt>Maybe A</tt>. OTOH, a field that is
--   nullable because of a <tt>nullable</tt> tag will remain with the same
--   type.
data WhyNullable
ByMaybeAttr :: WhyNullable
ByNullableAttr :: WhyNullable
data EntityDef
EntityDef :: !HaskellName -> !DBName -> !FieldDef -> ![Attr] -> ![FieldDef] -> ![UniqueDef] -> ![ForeignDef] -> ![Text] -> !(Map Text [ExtraLine]) -> !Bool -> EntityDef
[entityHaskell] :: EntityDef -> !HaskellName
[entityDB] :: EntityDef -> !DBName
[entityId] :: EntityDef -> !FieldDef
[entityAttrs] :: EntityDef -> ![Attr]
[entityFields] :: EntityDef -> ![FieldDef]
[entityUniques] :: EntityDef -> ![UniqueDef]
[entityForeigns] :: EntityDef -> ![ForeignDef]
[entityDerives] :: EntityDef -> ![Text]
[entityExtra] :: EntityDef -> !(Map Text [ExtraLine])
[entitySum] :: EntityDef -> !Bool
entityPrimary :: EntityDef -> Maybe CompositeDef
entityKeyFields :: EntityDef -> [FieldDef]
keyAndEntityFields :: EntityDef -> [FieldDef]
type ExtraLine = [Text]
newtype HaskellName
HaskellName :: Text -> HaskellName
[unHaskellName] :: HaskellName -> Text
newtype DBName
DBName :: Text -> DBName
[unDBName] :: DBName -> Text
type Attr = Text
data FieldType

-- | Optional module and name.
FTTypeCon :: (Maybe Text) -> Text -> FieldType
FTApp :: FieldType -> FieldType -> FieldType
FTList :: FieldType -> FieldType
data FieldDef
FieldDef :: !HaskellName -> !DBName -> !FieldType -> !SqlType -> ![Attr] -> !Bool -> !ReferenceDef -> FieldDef

-- | name of the field
[fieldHaskell] :: FieldDef -> !HaskellName
[fieldDB] :: FieldDef -> !DBName
[fieldType] :: FieldDef -> !FieldType
[fieldSqlType] :: FieldDef -> !SqlType

-- | user annotations for a field
[fieldAttrs] :: FieldDef -> ![Attr]

-- | a strict field in the data type. Default: true
[fieldStrict] :: FieldDef -> !Bool
[fieldReference] :: FieldDef -> !ReferenceDef

-- | There are 3 kinds of references 1) composite (to fields that exist in
--   the record) 2) single field 3) embedded
data ReferenceDef
NoReference :: ReferenceDef

-- | A ForeignRef has a late binding to the EntityDef it references via
--   HaskellName and has the Haskell type of the foreign key in the form of
--   FieldType
ForeignRef :: !HaskellName -> !FieldType -> ReferenceDef
EmbedRef :: EmbedEntityDef -> ReferenceDef
CompositeRef :: CompositeDef -> ReferenceDef

-- | A SelfReference stops an immediate cycle which causes non-termination
--   at compile-time (issue #311).
SelfReference :: ReferenceDef

-- | An EmbedEntityDef is the same as an EntityDef But it is only used for
--   fieldReference so it only has data needed for embedding
data EmbedEntityDef
EmbedEntityDef :: !HaskellName -> ![EmbedFieldDef] -> EmbedEntityDef
[embeddedHaskell] :: EmbedEntityDef -> !HaskellName
[embeddedFields] :: EmbedEntityDef -> ![EmbedFieldDef]

-- | An EmbedFieldDef is the same as a FieldDef But it is only used for
--   embeddedFields so it only has data needed for embedding
data EmbedFieldDef
EmbedFieldDef :: !DBName -> Maybe EmbedEntityDef -> Maybe HaskellName -> EmbedFieldDef
[emFieldDB] :: EmbedFieldDef -> !DBName
[emFieldEmbed] :: EmbedFieldDef -> Maybe EmbedEntityDef

-- | <a>emFieldEmbed</a> can create a cycle (issue #311) when a cycle is
--   detected, <a>emFieldEmbed</a> will be Nothing and <a>emFieldCycle</a>
--   will be Just
[emFieldCycle] :: EmbedFieldDef -> Maybe HaskellName
toEmbedEntityDef :: EntityDef -> EmbedEntityDef
data UniqueDef
UniqueDef :: !HaskellName -> !DBName -> ![(HaskellName, DBName)] -> ![Attr] -> UniqueDef
[uniqueHaskell] :: UniqueDef -> !HaskellName
[uniqueDBName] :: UniqueDef -> !DBName
[uniqueFields] :: UniqueDef -> ![(HaskellName, DBName)]
[uniqueAttrs] :: UniqueDef -> ![Attr]
data CompositeDef
CompositeDef :: ![FieldDef] -> ![Attr] -> CompositeDef
[compositeFields] :: CompositeDef -> ![FieldDef]
[compositeAttrs] :: CompositeDef -> ![Attr]

-- | Used instead of FieldDef to generate a smaller amount of code
type ForeignFieldDef = (HaskellName, DBName)
data ForeignDef
ForeignDef :: !HaskellName -> !DBName -> !HaskellName -> !DBName -> ![(ForeignFieldDef, ForeignFieldDef)] -> ![Attr] -> Bool -> ForeignDef
[foreignRefTableHaskell] :: ForeignDef -> !HaskellName
[foreignRefTableDBName] :: ForeignDef -> !DBName
[foreignConstraintNameHaskell] :: ForeignDef -> !HaskellName
[foreignConstraintNameDBName] :: ForeignDef -> !DBName
[foreignFields] :: ForeignDef -> ![(ForeignFieldDef, ForeignFieldDef)]
[foreignAttrs] :: ForeignDef -> ![Attr]
[foreignNullable] :: ForeignDef -> Bool
data PersistException

-- | Generic Exception
PersistError :: Text -> PersistException
PersistMarshalError :: Text -> PersistException
PersistInvalidField :: Text -> PersistException
PersistForeignConstraintUnmet :: Text -> PersistException
PersistMongoDBError :: Text -> PersistException
PersistMongoDBUnsupported :: Text -> PersistException

-- | A raw value which can be stored in any backend and can be marshalled
--   to and from a <tt>PersistField</tt>.
data PersistValue
PersistText :: Text -> PersistValue
PersistByteString :: ByteString -> PersistValue
PersistInt64 :: Int64 -> PersistValue
PersistDouble :: Double -> PersistValue
PersistRational :: Rational -> PersistValue
PersistBool :: Bool -> PersistValue
PersistDay :: Day -> PersistValue
PersistTimeOfDay :: TimeOfDay -> PersistValue
PersistUTCTime :: UTCTime -> PersistValue
PersistNull :: PersistValue
PersistList :: [PersistValue] -> PersistValue
PersistMap :: [(Text, PersistValue)] -> PersistValue

-- | Intended especially for MongoDB backend
PersistObjectId :: ByteString -> PersistValue

-- | Using <a>PersistDbSpecific</a> allows you to use types specific to a
--   particular backend For example, below is a simple example of the
--   PostGIS geography type:
--   
--   <pre>
--   data Geo = Geo ByteString
--   
--   instance PersistField Geo where
--     toPersistValue (Geo t) = PersistDbSpecific t
--   
--     fromPersistValue (PersistDbSpecific t) = Right $ Geo $ Data.ByteString.concat ["'", t, "'"]
--     fromPersistValue _ = Left "Geo values must be converted from PersistDbSpecific"
--   
--   instance PersistFieldSql Geo where
--     sqlType _ = SqlOther "GEOGRAPHY(POINT,4326)"
--   
--   toPoint :: Double -&gt; Double -&gt; Geo
--   toPoint lat lon = Geo $ Data.ByteString.concat ["'POINT(", ps $ lon, " ", ps $ lat, ")'"]
--     where ps = Data.Text.pack . show
--   </pre>
--   
--   If Foo has a geography field, we can then perform insertions like the
--   following:
--   
--   <pre>
--   insert $ Foo (toPoint 44 44)
--   </pre>
PersistDbSpecific :: ByteString -> PersistValue
fromPersistValueText :: PersistValue -> Either Text Text

-- | A SQL data type. Naming attempts to reflect the underlying Haskell
--   datatypes, eg SqlString instead of SqlVarchar. Different SQL databases
--   may have different translations for these types.
data SqlType
SqlString :: SqlType
SqlInt32 :: SqlType
SqlInt64 :: SqlType
SqlReal :: SqlType
SqlNumeric :: Word32 -> Word32 -> SqlType
SqlBool :: SqlType
SqlDay :: SqlType
SqlTime :: SqlType

-- | Always uses UTC timezone
SqlDayTime :: SqlType
SqlBlob :: SqlType

-- | a backend-specific name
SqlOther :: Text -> SqlType
data PersistFilter
Eq :: PersistFilter
Ne :: PersistFilter
Gt :: PersistFilter
Lt :: PersistFilter
Ge :: PersistFilter
Le :: PersistFilter
In :: PersistFilter
NotIn :: PersistFilter
BackendSpecificFilter :: Text -> PersistFilter
data UpdateException
KeyNotFound :: String -> UpdateException
UpsertError :: String -> UpdateException
data OnlyUniqueException
OnlyUniqueException :: String -> OnlyUniqueException
data PersistUpdate
Assign :: PersistUpdate
Add :: PersistUpdate
Subtract :: PersistUpdate
Multiply :: PersistUpdate
Divide :: PersistUpdate
BackendSpecificUpdate :: Text -> PersistUpdate
data SomePersistField
SomePersistField :: a -> SomePersistField

-- | Updating a database entity.
--   
--   Persistent users use combinators to create these.
data Update record
Update :: EntityField record typ -> typ -> PersistUpdate -> Update record
[updateField] :: Update record -> EntityField record typ
[updateValue] :: Update record -> typ
[updateUpdate] :: Update record -> PersistUpdate
BackendUpdate :: (BackendSpecificUpdate (PersistEntityBackend record) record) -> Update record

-- | Query options.
--   
--   Persistent users use these directly.
data SelectOpt record
Asc :: (EntityField record typ) -> SelectOpt record
Desc :: (EntityField record typ) -> SelectOpt record
OffsetBy :: Int -> SelectOpt record
LimitTo :: Int -> SelectOpt record

-- | Filters which are available for <tt>select</tt>, <tt>updateWhere</tt>
--   and <tt>deleteWhere</tt>. Each filter constructor specifies the field
--   being filtered on, the type of comparison applied (equals, not equals,
--   etc) and the argument for the comparison.
--   
--   Persistent users use combinators to create these.
data Filter record
Filter :: EntityField record typ -> Either typ [typ] -> PersistFilter -> Filter record
[filterField] :: Filter record -> EntityField record typ
[filterValue] :: Filter record -> Either typ [typ]
[filterFilter] :: Filter record -> PersistFilter

-- | convenient for internal use, not needed for the API
FilterAnd :: [Filter record] -> Filter record
FilterOr :: [Filter record] -> Filter record
BackendFilter :: (BackendSpecificFilter (PersistEntityBackend record) record) -> Filter record

-- | Datatype that represents an entity, with both its <a>Key</a> and its
--   Haskell record representation.
--   
--   When using a SQL-based backend (such as SQLite or PostgreSQL), an
--   <a>Entity</a> may take any number of columns depending on how many
--   fields it has. In order to reconstruct your entity on the Haskell
--   side, <tt>persistent</tt> needs all of your entity columns and in the
--   right order. Note that you don't need to worry about this when using
--   <tt>persistent</tt>'s API since everything is handled correctly behind
--   the scenes.
--   
--   However, if you want to issue a raw SQL command that returns an
--   <a>Entity</a>, then you have to be careful with the column order.
--   While you could use <tt>SELECT Entity.* WHERE ...</tt> and that would
--   work most of the time, there are times when the order of the columns
--   on your database is different from the order that <tt>persistent</tt>
--   expects (for example, if you add a new field in the middle of you
--   entity definition and then use the migration code --
--   <tt>persistent</tt> will expect the column to be in the middle, but
--   your DBMS will put it as the last column). So, instead of using a
--   query like the one above, you may use <a>rawSql</a> (from the
--   <a>Database.Persist.GenericSql</a> module) with its /entity selection
--   placeholder/ (a double question mark <tt>??</tt>). Using
--   <tt>rawSql</tt> the query above must be written as <tt>SELECT ?? WHERE
--   ..</tt>. Then <tt>rawSql</tt> will replace <tt>??</tt> with the list
--   of all columns that we need from your entity in the right order. If
--   your query returns two entities (i.e. <tt>(Entity backend a, Entity
--   backend b)</tt>), then you must you use <tt>SELECT ??, ?? WHERE
--   ...</tt>, and so on.
data Entity record
Entity :: Key record -> record -> Entity record
[entityKey] :: Entity record -> Key record
[entityVal] :: Entity record -> record

module Database.Persist.Quasi

-- | Parses a quasi-quoted syntax into a list of entity definitions.
parse :: PersistSettings -> Text -> [EntityDef]
data PersistSettings
PersistSettings :: !(Text -> Text) -> !Bool -> !Text -> PersistSettings
[psToDBName] :: PersistSettings -> !(Text -> Text)

-- | Whether fields are by default strict. Default value: <tt>True</tt>.
--   
--   Since 1.2
[psStrictFields] :: PersistSettings -> !Bool

-- | The name of the id column. Default value: <tt>id</tt> The name of the
--   id column can also be changed on a per-model basis
--   <a>https://github.com/yesodweb/persistent/wiki/Persistent-entity-syntax</a>
--   
--   Since 2.0
[psIdName] :: PersistSettings -> !Text
upperCaseSettings :: PersistSettings
lowerCaseSettings :: PersistSettings
nullable :: [Text] -> IsNullable
instance GHC.Classes.Eq Database.Persist.Quasi.Token
instance GHC.Show.Show Database.Persist.Quasi.Token
instance GHC.Show.Show a => GHC.Show.Show (Database.Persist.Quasi.ParseState a)

module Database.Persist.Class

-- | <a>ToBackendKey</a> converts a <a>PersistEntity</a> <a>Key</a> into a
--   <a>BackendKey</a> This can be used by each backend to convert between
--   a <a>Key</a> and a plain Haskell type. For Sql, that is done with
--   <tt>toSqlKey</tt> and <tt>fromSqlKey</tt>.
--   
--   By default, a <a>PersistEntity</a> uses the default <a>BackendKey</a>
--   for its Key and is an instance of ToBackendKey
--   
--   A <a>Key</a> that instead uses a custom type will not be an instance
--   of <a>ToBackendKey</a>.
class (PersistEntity record, PersistEntityBackend record ~ backend, PersistCore backend) => ToBackendKey backend record
toBackendKey :: ToBackendKey backend record => Key record -> BackendKey backend
fromBackendKey :: ToBackendKey backend record => BackendKey backend -> Key record
class PersistCore backend where data BackendKey backend where {
    data family BackendKey backend;
}

-- | A backwards-compatible alias for those that don't care about
--   distinguishing between read and write queries. It signifies the
--   assumption that, by default, a backend can write as well as read.
type PersistStore a = PersistStoreWrite a
class (Show (BackendKey backend), Read (BackendKey backend), Eq (BackendKey backend), Ord (BackendKey backend), PersistCore backend, PersistField (BackendKey backend), ToJSON (BackendKey backend), FromJSON (BackendKey backend)) => PersistStoreRead backend

-- | Get a record by identifier, if available.
get :: (PersistStoreRead backend, MonadIO m, PersistRecordBackend record backend) => Key record -> ReaderT backend m (Maybe record)
class (Show (BackendKey backend), Read (BackendKey backend), Eq (BackendKey backend), Ord (BackendKey backend), PersistStoreRead backend, PersistField (BackendKey backend), ToJSON (BackendKey backend), FromJSON (BackendKey backend)) => PersistStoreWrite backend where insert_ record = insert record >> return () insertMany = mapM insert insertMany_ x = insertMany x >> return () insertEntityMany = mapM_ (\ (Entity k record) -> insertKey k record) updateGet key ups = do { update key ups; get key >>= maybe (liftIO $ throwIO $ KeyNotFound $ show key) return }

-- | Create a new record in the database, returning an automatically
--   created key (in SQL an auto-increment id).
insert :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> ReaderT backend m (Key record)

-- | Same as <a>insert</a>, but doesn't return a <tt>Key</tt>.
insert_ :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> ReaderT backend m ()

-- | Create multiple records in the database and return their <a>Key</a>s.
--   
--   If you don't need the inserted <a>Key</a>s, use <a>insertMany_</a>.
--   
--   The MongoDB and PostgreSQL backends insert all records and retrieve
--   their keys in one database query.
--   
--   The SQLite and MySQL backends use the slow, default implementation of
--   <tt>mapM insert</tt>.
insertMany :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [record] -> ReaderT backend m [Key record]

-- | Same as <a>insertMany</a>, but doesn't return any <a>Key</a>s.
--   
--   The MongoDB, PostgreSQL, SQLite and MySQL backends insert all records
--   in one database query.
insertMany_ :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [record] -> ReaderT backend m ()

-- | Same as <a>insertMany_</a>, but takes an <a>Entity</a> instead of just
--   a record.
--   
--   Useful when migrating data from one entity to another and want to
--   preserve ids.
--   
--   The MongoDB backend inserts all the entities in one database query.
--   
--   The SQL backends use the slow, default implementation of <tt>mapM_
--   insertKey</tt>.
insertEntityMany :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => [Entity record] -> ReaderT backend m ()

-- | Create a new record in the database using the given key.
insertKey :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> record -> ReaderT backend m ()

-- | Put the record in the database with the given key. Unlike
--   <a>replace</a>, if a record with the given key does not exist then a
--   new record will be inserted.
repsert :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> record -> ReaderT backend m ()

-- | Replace the record in the database with the given key. Note that the
--   result is undefined if such record does not exist, so you must use
--   'insertKey or <a>repsert</a> in these cases.
replace :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> record -> ReaderT backend m ()

-- | Delete a specific record by identifier. Does nothing if record does
--   not exist.
delete :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> ReaderT backend m ()

-- | Update individual fields on a specific record.
update :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> [Update record] -> ReaderT backend m ()

-- | Update individual fields on a specific record, and retrieve the
--   updated value from the database.
--   
--   Note that this function will throw an exception if the given key is
--   not found in the database.
updateGet :: (PersistStoreWrite backend, MonadIO m, PersistRecordBackend record backend) => Key record -> [Update record] -> ReaderT backend m record

-- | A convenient alias for common type signatures
type PersistRecordBackend record backend = (PersistEntity record, PersistEntityBackend record ~ BaseBackend backend)

-- | Same as <a>get</a>, but for a non-null (not Maybe) foreign key Unsafe
--   unless your database is enforcing that the foreign key is valid.
getJust :: (PersistStoreRead backend, Show (Key record), PersistRecordBackend record backend, MonadIO m) => Key record -> ReaderT backend m record

-- | Same as <a>getJust</a>, but returns an <a>Entity</a> instead of just
--   the record. @since 2.6.1
getJustEntity :: (PersistEntityBackend record ~ BaseBackend backend, MonadIO m, PersistEntity record, PersistStoreRead backend) => Key record -> ReaderT backend m (Entity record)

-- | Like <tt>get</tt>, but returns the complete <tt>Entity</tt>.
getEntity :: (PersistStoreWrite backend, PersistRecordBackend e backend, MonadIO m) => Key e -> ReaderT backend m (Maybe (Entity e))

-- | Curry this to make a convenience function that loads an associated
--   model.
--   
--   <pre>
--   foreign = belongsTo foreignId
--   </pre>
belongsTo :: (PersistStoreRead backend, PersistEntity ent1, PersistRecordBackend ent2 backend, MonadIO m) => (ent1 -> Maybe (Key ent2)) -> ent1 -> ReaderT backend m (Maybe ent2)

-- | Same as <a>belongsTo</a>, but uses <tt>getJust</tt> and therefore is
--   similarly unsafe.
belongsToJust :: (PersistStoreRead backend, PersistEntity ent1, PersistRecordBackend ent2 backend, MonadIO m) => (ent1 -> Key ent2) -> ent1 -> ReaderT backend m ent2

-- | Like <tt>insert</tt>, but returns the complete <tt>Entity</tt>.
insertEntity :: (PersistStoreWrite backend, PersistRecordBackend e backend, MonadIO m) => e -> ReaderT backend m (Entity e)

-- | Like <a>insertEntity</a> but just returns the record instead of
--   <a>Entity</a>. @since 2.6.1
insertRecord :: (PersistEntityBackend record ~ BaseBackend backend, PersistEntity record, MonadIO m, PersistStoreWrite backend) => record -> ReaderT backend m record

-- | A backwards-compatible alias for those that don't care about
--   distinguishing between read and write queries. It signifies the
--   assumption that, by default, a backend can write as well as read.
type PersistUnique a = PersistUniqueWrite a

-- | Queries against <a>Unique</a> keys (other than the id <a>Key</a>).
--   
--   Please read the general Persistent documentation to learn how to
--   create <a>Unique</a> keys.
--   
--   Using this with an Entity without a Unique key leads to undefined
--   behavior. A few of these functions require a <i>single</i>
--   <a>Unique</a>, so using an Entity with multiple <a>Unique</a>s is also
--   undefined. In these cases persistent's goal is to throw an exception
--   as soon as possible, but persistent is still transitioning to that.
--   
--   SQL backends automatically create uniqueness constraints, but for
--   MongoDB you must manually place a unique index on a field to have a
--   uniqueness constraint.
class (PersistCore backend, PersistStoreRead backend) => PersistUniqueRead backend

-- | Get a record by unique key, if available. Returns also the identifier.
getBy :: (PersistUniqueRead backend, MonadIO m, PersistRecordBackend record backend) => Unique record -> ReaderT backend m (Maybe (Entity record))

-- | Some functions in this module (<a>insertUnique</a>, <a>insertBy</a>,
--   and <a>replaceUnique</a>) first query the unique indexes to check for
--   conflicts. You could instead optimistically attempt to perform the
--   operation (e.g. <a>replace</a> instead of <a>replaceUnique</a>).
--   However,
--   
--   <ul>
--   <li>there is some fragility to trying to catch the correct exception
--   and determing the column of failure;</li>
--   <li>an exception will automatically abort the current SQL
--   transaction.</li>
--   </ul>
class (PersistUniqueRead backend, PersistStoreWrite backend) => PersistUniqueWrite backend where insertUnique datum = do { conflict <- checkUnique datum; case conflict of { Nothing -> Just `liftM` insert datum Just _ -> return Nothing } } upsert record updates = do { uniqueKey <- onlyUnique record; upsertBy uniqueKey record updates } upsertBy uniqueKey record updates = do { mExists <- getBy uniqueKey; k <- case mExists of { Just (Entity k _) -> do { when (null updates) (replace k record); return k } Nothing -> insert record }; Entity k `liftM` updateGet k updates }

-- | Delete a specific record by unique key. Does nothing if no record
--   matches.
deleteBy :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => Unique record -> ReaderT backend m ()

-- | Like <a>insert</a>, but returns <a>Nothing</a> when the record
--   couldn't be inserted because of a uniqueness constraint.
insertUnique :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> ReaderT backend m (Maybe (Key record))

-- | Update based on a uniqueness constraint or insert:
--   
--   <ul>
--   <li>insert the new record if it does not exist;</li>
--   <li>update the existing record that matches the uniqueness
--   contraint.</li>
--   </ul>
--   
--   Throws an exception if there is more than 1 uniqueness contraint.
upsert :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => record -> [Update record] -> ReaderT backend m (Entity record)

-- | Update based on a given uniqueness constraint or insert:
--   
--   <ul>
--   <li>insert the new record if it does not exist;</li>
--   <li>update the existing record that matches the given uniqueness
--   contraint.</li>
--   </ul>
upsertBy :: (PersistUniqueWrite backend, MonadIO m, PersistRecordBackend record backend) => Unique record -> record -> [Update record] -> ReaderT backend m (Entity record)

-- | A modification of <a>getBy</a>, which takes the <a>PersistEntity</a>
--   itself instead of a <a>Unique</a> record. Returns a record matching
--   <i>one</i> of the unique keys. This function makes the most sense on
--   entities with a single <a>Unique</a> constructor.
getByValue :: (MonadIO m, PersistUniqueRead backend, PersistRecordBackend record backend) => record -> ReaderT backend m (Maybe (Entity record))

-- | Insert a value, checking for conflicts with any unique constraints. If
--   a duplicate exists in the database, it is returned as <a>Left</a>.
--   Otherwise, the new 'Key is returned as <a>Right</a>.
insertBy :: (MonadIO m, PersistUniqueWrite backend, PersistRecordBackend record backend) => record -> ReaderT backend m (Either (Entity record) (Key record))

-- | Attempt to replace the record of the given key with the given new
--   record. First query the unique fields to make sure the replacement
--   maintains uniqueness constraints.
--   
--   Return <a>Nothing</a> if the replacement was made. If uniqueness is
--   violated, return a <a>Just</a> with the <a>Unique</a> violation
--   
--   Since 1.2.2.0
replaceUnique :: (MonadIO m, Eq record, Eq (Unique record), PersistRecordBackend record backend, PersistUniqueWrite backend) => Key record -> record -> ReaderT backend m (Maybe (Unique record))

-- | Check whether there are any conflicts for unique keys with this entity
--   and existing entities in the database.
--   
--   Returns <a>Nothing</a> if the entity would be unique, and could thus
--   safely be inserted. on a conflict returns the conflicting key
checkUnique :: (MonadIO m, PersistRecordBackend record backend, PersistUniqueRead backend) => record -> ReaderT backend m (Maybe (Unique record))

-- | Return the single unique key for a record.
onlyUnique :: (MonadIO m, PersistUniqueWrite backend, PersistRecordBackend record backend) => record -> ReaderT backend m (Unique record)

-- | A backwards-compatible alias for those that don't care about
--   distinguishing between read and write queries. It signifies the
--   assumption that, by default, a backend can write as well as read.
type PersistQuery a = PersistQueryWrite a

-- | Backends supporting conditional read operations.
class (PersistCore backend, PersistStoreRead backend) => PersistQueryRead backend where selectFirst filts opts = do { srcRes <- selectSourceRes filts (LimitTo 1 : opts); liftIO $ with srcRes ($$ head) }

-- | Get all records matching the given criterion in the specified order.
--   Returns also the identifiers.
selectSourceRes :: (PersistQueryRead backend, PersistRecordBackend record backend, MonadIO m1, MonadIO m2) => [Filter record] -> [SelectOpt record] -> ReaderT backend m1 (Acquire (Source m2 (Entity record)))

-- | Get just the first record for the criterion.
selectFirst :: (PersistQueryRead backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> [SelectOpt record] -> ReaderT backend m (Maybe (Entity record))

-- | Get the <a>Key</a>s of all records matching the given criterion.
selectKeysRes :: (PersistQueryRead backend, MonadIO m1, MonadIO m2, PersistRecordBackend record backend) => [Filter record] -> [SelectOpt record] -> ReaderT backend m1 (Acquire (Source m2 (Key record)))

-- | The total number of records fulfilling the given criterion.
count :: (PersistQueryRead backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> ReaderT backend m Int

-- | Backends supporting conditional write operations
class (PersistQueryRead backend, PersistStoreWrite backend) => PersistQueryWrite backend

-- | Update individual fields on any record matching the given criterion.
updateWhere :: (PersistQueryWrite backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> [Update record] -> ReaderT backend m ()

-- | Delete all records matching the given criterion.
deleteWhere :: (PersistQueryWrite backend, MonadIO m, PersistRecordBackend record backend) => [Filter record] -> ReaderT backend m ()

-- | Get all records matching the given criterion in the specified order.
--   Returns also the identifiers.
selectSource :: (PersistQueryRead (BaseBackend backend), MonadResource m, PersistEntity record, PersistEntityBackend record ~ BaseBackend (BaseBackend backend), MonadReader backend m, HasPersistBackend backend) => [Filter record] -> [SelectOpt record] -> Source m (Entity record)

-- | Get the <a>Key</a>s of all records matching the given criterion.
selectKeys :: (PersistQueryRead (BaseBackend backend), MonadResource m, PersistEntity record, BaseBackend (BaseBackend backend) ~ PersistEntityBackend record, MonadReader backend m, HasPersistBackend backend) => [Filter record] -> [SelectOpt record] -> Source m (Key record)

-- | Call <a>selectSource</a> but return the result as a list.
selectList :: (MonadIO m, PersistQueryRead backend, PersistRecordBackend record backend) => [Filter record] -> [SelectOpt record] -> ReaderT backend m [Entity record]

-- | Call <a>selectKeys</a> but return the result as a list.
selectKeysList :: (MonadIO m, PersistQueryRead backend, PersistRecordBackend record backend) => [Filter record] -> [SelectOpt record] -> ReaderT backend m [Key record]

-- | For combinations of backends and entities that support
--   cascade-deletion. “Cascade-deletion” means that entries that depend on
--   other entries to be deleted will be deleted as well.
class (PersistStoreWrite backend, PersistEntity record, BaseBackend backend ~ PersistEntityBackend record) => DeleteCascade record backend

-- | Perform cascade-deletion of single database entry.
deleteCascade :: (DeleteCascade record backend, MonadIO m) => Key record -> ReaderT backend m ()

-- | Cascade-deletion of entries satisfying given filters.
deleteCascadeWhere :: (MonadIO m, DeleteCascade record backend, PersistQueryWrite backend) => [Filter record] -> ReaderT backend m ()

-- | Persistent serialized Haskell records to the database. A Database
--   <a>Entity</a> (A row in SQL, a document in MongoDB, etc) corresponds
--   to a <a>Key</a> plus a Haskell record.
--   
--   For every Haskell record type stored in the database there is a
--   corresponding <a>PersistEntity</a> instance. An instance of
--   PersistEntity contains meta-data for the record. PersistEntity also
--   helps abstract over different record types. That way the same query
--   interface can return a <a>PersistEntity</a>, with each query returning
--   different types of Haskell records.
--   
--   Some advanced type system capabilities are used to make this process
--   type-safe. Persistent users usually don't need to understand the class
--   associated data and functions.
class (PersistField (Key record), ToJSON (Key record), FromJSON (Key record), Show (Key record), Read (Key record), Eq (Key record), Ord (Key record)) => PersistEntity record where type PersistEntityBackend record data Key record data EntityField record :: * -> * data Unique record where {
    type family PersistEntityBackend record;
    data family Key record;
    data family EntityField record :: * -> *;
    data family Unique record;
}

-- | A lower-level key operation.
keyToValues :: PersistEntity record => Key record -> [PersistValue]

-- | A lower-level key operation.
keyFromValues :: PersistEntity record => [PersistValue] -> Either Text (Key record)

-- | A meta-operation to retrieve the <a>Key</a> <a>EntityField</a>.
persistIdField :: PersistEntity record => EntityField record (Key record)

-- | Retrieve the <a>EntityDef</a> meta-data for the record.
entityDef :: (PersistEntity record, Monad m) => m record -> EntityDef

-- | Return meta-data for a given <a>EntityField</a>.
persistFieldDef :: PersistEntity record => EntityField record typ -> FieldDef

-- | A meta-operation to get the database fields of a record.
toPersistFields :: PersistEntity record => record -> [SomePersistField]

-- | A lower-level operation to convert from database values to a Haskell
--   record.
fromPersistValues :: PersistEntity record => [PersistValue] -> Either Text record

-- | A meta operation to retrieve all the <a>Unique</a> keys.
persistUniqueKeys :: PersistEntity record => record -> [Unique record]

-- | A lower level operation.
persistUniqueToFieldNames :: PersistEntity record => Unique record -> [(HaskellName, DBName)]

-- | A lower level operation.
persistUniqueToValues :: PersistEntity record => Unique record -> [PersistValue]

-- | Use a <a>PersistField</a> as a lens.
fieldLens :: PersistEntity record => EntityField record field -> (forall f. Functor f => (field -> f field) -> Entity record -> f (Entity record))

-- | A value which can be marshalled to and from a <a>PersistValue</a>.
class PersistField a
toPersistValue :: PersistField a => a -> PersistValue
fromPersistValue :: PersistField a => PersistValue -> Either Text a

-- | Represents a value containing all the configuration options for a
--   specific backend. This abstraction makes it easier to write code that
--   can easily swap backends.
class PersistConfig c where type PersistConfigBackend c :: (* -> *) -> * -> * type PersistConfigPool c applyEnv = return where {
    type family PersistConfigBackend c :: (* -> *) -> * -> *;
    type family PersistConfigPool c;
}

-- | Load the config settings from a <a>Value</a>, most likely taken from a
--   YAML config file.
loadConfig :: PersistConfig c => Value -> Parser c

-- | Modify the config settings based on environment variables.
applyEnv :: PersistConfig c => c -> IO c

-- | Create a new connection pool based on the given config settings.
createPoolConfig :: PersistConfig c => c -> IO (PersistConfigPool c)

-- | Run a database action by taking a connection from the pool.
runPool :: (PersistConfig c, MonadBaseControl IO m, MonadIO m) => c -> PersistConfigBackend c m a -> PersistConfigPool c -> m a

-- | Get list of values corresponding to given entity.
entityValues :: PersistEntity record => Entity record -> [PersistValue]

-- | Class which allows the plucking of a <tt>BaseBackend backend</tt> from
--   some larger type. For example, <tt> instance HasPersistBackend
--   (SqlReadBackend, Int) where type BaseBackend (SqlReadBackend, Int) =
--   SqlBackend persistBackend = unSqlReadBackend . fst </tt>
class HasPersistBackend backend where type BaseBackend backend where {
    type family BaseBackend backend;
}
persistBackend :: HasPersistBackend backend => backend -> BaseBackend backend

-- | Class which witnesses that <tt>backend</tt> is essentially the same as
--   <tt>BaseBackend backend</tt>. That is, they're isomorphic and
--   <tt>backend</tt> is just some wrapper over <tt>BaseBackend
--   backend</tt>.
class (HasPersistBackend backend) => IsPersistBackend backend
liftPersist :: (MonadIO m, MonadReader backend m, HasPersistBackend backend) => ReaderT (BaseBackend backend) IO b -> m b

-- | Predefined <tt>toJSON</tt>. The resulting JSON looks like <tt>{"key":
--   1, "value": {"name": ...}}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance ToJSON (Entity User) where
--       toJSON = keyValueEntityToJSON
--   </pre>
keyValueEntityToJSON :: (PersistEntity record, ToJSON record, ToJSON (Key record)) => Entity record -> Value

-- | Predefined <tt>parseJSON</tt>. The input JSON looks like <tt>{"key":
--   1, "value": {"name": ...}}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance FromJSON (Entity User) where
--       parseJSON = keyValueEntityFromJSON
--   </pre>
keyValueEntityFromJSON :: (PersistEntity record, FromJSON record, FromJSON (Key record)) => Value -> Parser (Entity record)

-- | Predefined <tt>toJSON</tt>. The resulting JSON looks like <tt>{"id":
--   1, "name": ...}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance ToJSON (Entity User) where
--       toJSON = entityIdToJSON
--   </pre>
entityIdToJSON :: (PersistEntity record, ToJSON record, ToJSON (Key record)) => Entity record -> Value

-- | Predefined <tt>parseJSON</tt>. The input JSON looks like <tt>{"id": 1,
--   "name": ...}</tt>.
--   
--   The typical usage is:
--   
--   <pre>
--   instance FromJSON (Entity User) where
--       parseJSON = entityIdFromJSON
--   </pre>
entityIdFromJSON :: (PersistEntity record, FromJSON record, FromJSON (Key record)) => Value -> Parser (Entity record)

-- | Convenience function for getting a free <a>PersistField</a> instance
--   from a type with JSON instances.
--   
--   Example usage in combination with <a>fromPersistValueJSON</a>:
--   
--   <pre>
--   instance PersistField MyData where
--     fromPersistValue = fromPersistValueJSON
--     toPersistValue = toPersistValueJSON
--   </pre>
toPersistValueJSON :: ToJSON a => a -> PersistValue

-- | Convenience function for getting a free <a>PersistField</a> instance
--   from a type with JSON instances. The JSON parser used will accept JSON
--   values other that object and arrays. So, if your instance serializes
--   the data to a JSON string, this will still work.
--   
--   Example usage in combination with <a>toPersistValueJSON</a>:
--   
--   <pre>
--   instance PersistField MyData where
--     fromPersistValue = fromPersistValueJSON
--     toPersistValue = toPersistValueJSON
--   </pre>
fromPersistValueJSON :: FromJSON a => PersistValue -> Either Text a

module Database.Persist.Sql.Types.Internal

-- | Class which allows the plucking of a <tt>BaseBackend backend</tt> from
--   some larger type. For example, <tt> instance HasPersistBackend
--   (SqlReadBackend, Int) where type BaseBackend (SqlReadBackend, Int) =
--   SqlBackend persistBackend = unSqlReadBackend . fst </tt>
class HasPersistBackend backend where type BaseBackend backend where {
    type family BaseBackend backend;
}
persistBackend :: HasPersistBackend backend => backend -> BaseBackend backend

-- | Class which witnesses that <tt>backend</tt> is essentially the same as
--   <tt>BaseBackend backend</tt>. That is, they're isomorphic and
--   <tt>backend</tt> is just some wrapper over <tt>BaseBackend
--   backend</tt>.
class (HasPersistBackend backend) => IsPersistBackend backend

-- | This function is how we actually construct and tag a backend as having
--   read or write capabilities. It should be used carefully and only when
--   actually constructing a <tt>backend</tt>. Careless use allows us to
--   accidentally run a write query against a read-only database.
mkPersistBackend :: IsPersistBackend backend => BaseBackend backend -> backend

-- | An SQL backend which can only handle read queries
data SqlReadBackend

-- | An SQL backend which can handle read or write queries
data SqlWriteBackend

-- | Useful for running a read query against a backend with unknown
--   capabilities.
readToUnknown :: Monad m => ReaderT SqlReadBackend m a -> ReaderT SqlBackend m a

-- | Useful for running a read query against a backend with read and write
--   capabilities.
readToWrite :: Monad m => ReaderT SqlReadBackend m a -> ReaderT SqlWriteBackend m a

-- | Useful for running a write query against an untagged backend with
--   unknown capabilities.
writeToUnknown :: Monad m => ReaderT SqlWriteBackend m a -> ReaderT SqlBackend m a
type LogFunc = Loc -> LogSource -> LogLevel -> LogStr -> IO ()
data InsertSqlResult
ISRSingle :: Text -> InsertSqlResult
ISRInsertGet :: Text -> Text -> InsertSqlResult
ISRManyKeys :: Text -> [PersistValue] -> InsertSqlResult
data Statement
Statement :: IO () -> IO () -> ([PersistValue] -> IO Int64) -> (forall m. MonadIO m => [PersistValue] -> Acquire (Source m [PersistValue])) -> Statement
[stmtFinalize] :: Statement -> IO ()
[stmtReset] :: Statement -> IO ()
[stmtExecute] :: Statement -> [PersistValue] -> IO Int64
[stmtQuery] :: Statement -> forall m. MonadIO m => [PersistValue] -> Acquire (Source m [PersistValue])
data SqlBackend
SqlBackend :: (Text -> IO Statement) -> (EntityDef -> [PersistValue] -> InsertSqlResult) -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult) -> Maybe (EntityDef -> Text -> Text) -> IORef (Map Text Statement) -> IO () -> ([EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> (DBName -> Text) -> Text -> Text -> ((Int, Int) -> Bool -> Text -> Text) -> LogFunc -> Maybe Int -> SqlBackend
[connPrepare] :: SqlBackend -> Text -> IO Statement

-- | table name, column names, id name, either 1 or 2 statements to run
[connInsertSql] :: SqlBackend -> EntityDef -> [PersistValue] -> InsertSqlResult

-- | SQL for inserting many rows and returning their primary keys, for
--   backends that support this functioanlity. If <a>Nothing</a>, rows will
--   be inserted one-at-a-time using <a>connInsertSql</a>.
[connInsertManySql] :: SqlBackend -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult)
[connUpsertSql] :: SqlBackend -> Maybe (EntityDef -> Text -> Text)
[connStmtMap] :: SqlBackend -> IORef (Map Text Statement)
[connClose] :: SqlBackend -> IO ()
[connMigrateSql] :: SqlBackend -> [EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])
[connBegin] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connCommit] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connRollback] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connEscapeName] :: SqlBackend -> DBName -> Text
[connNoLimit] :: SqlBackend -> Text
[connRDBMS] :: SqlBackend -> Text
[connLimitOffset] :: SqlBackend -> (Int, Int) -> Bool -> Text -> Text
[connLogFunc] :: SqlBackend -> LogFunc

-- | Some databases (probably only Sqlite) have a limit on how many
--   question-mark parameters may be used in a statement
[connMaxParams] :: SqlBackend -> Maybe Int

-- | A constraint synonym which witnesses that a backend is SQL and can run
--   read queries.
type SqlBackendCanRead backend = (IsSqlBackend backend, PersistQueryRead backend, PersistStoreRead backend, PersistUniqueRead backend)

-- | A constraint synonym which witnesses that a backend is SQL and can run
--   read and write queries.
type SqlBackendCanWrite backend = (SqlBackendCanRead backend, PersistQueryWrite backend, PersistStoreWrite backend, PersistUniqueWrite backend)

-- | Like <tt>SqlPersistT</tt> but compatible with any SQL backend which
--   can handle read queries.
type SqlReadT m a = forall backend. (SqlBackendCanRead backend) => ReaderT backend m a

-- | Like <tt>SqlPersistT</tt> but compatible with any SQL backend which
--   can handle read and write queries.
type SqlWriteT m a = forall backend. (SqlBackendCanWrite backend) => ReaderT backend m a

-- | A backend which is a wrapper around <tt>SqlBackend</tt>.
type IsSqlBackend backend = (IsPersistBackend backend, BaseBackend backend ~ SqlBackend)
instance Database.Persist.Class.PersistStore.HasPersistBackend Database.Persist.Sql.Types.Internal.SqlBackend
instance Database.Persist.Class.PersistStore.IsPersistBackend Database.Persist.Sql.Types.Internal.SqlBackend
instance Database.Persist.Class.PersistStore.HasPersistBackend Database.Persist.Sql.Types.Internal.SqlReadBackend
instance Database.Persist.Class.PersistStore.IsPersistBackend Database.Persist.Sql.Types.Internal.SqlReadBackend
instance Database.Persist.Class.PersistStore.HasPersistBackend Database.Persist.Sql.Types.Internal.SqlWriteBackend
instance Database.Persist.Class.PersistStore.IsPersistBackend Database.Persist.Sql.Types.Internal.SqlWriteBackend

module Database.Persist

-- | Assign a field a value.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   updateAge :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   updateAge = updateWhere [UserName ==. "SPJ" ] [UserAge =. 45]
--   </pre>
--   
--   Similar to <a>updateWhere</a> which is shown in the above example you
--   can use other functions present in the module
--   <a>Database.Persist.Class</a>. Note that the first parameter of
--   <a>updateWhere</a> is [<a>Filter</a> val] and second parameter is
--   [<a>Update</a> val]. By comparing this with the type of <a>==.</a> and
--   <a>=.</a>, you can see that they match up in the above usage.
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+--------+
--   |id   |name |age     |
--   +-----+-----+--------+
--   |1    |SPJ  |40 -&gt; 45|
--   +-----+-----+--------+
--   |2    |Simon|41      |
--   +-----+-----+--------+
--   </pre>
(=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Update v
infixr 3 =.

-- | Assign a field by addition (<tt>+=</tt>).
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   addAge :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   addAge = updateWhere [UserName ==. "SPJ" ] [UserAge +=. 1]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+---------+
--   |id   |name |age      |
--   +-----+-----+---------+
--   |1    |SPJ  |40 -&gt; 41 |
--   +-----+-----+---------+
--   |2    |Simon|41       |
--   +-----+-----+---------+
--   </pre>
(+=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Update v
infixr 3 +=.

-- | Assign a field by subtraction (<tt>-=</tt>).
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   subtractAge :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   subtractAge = updateWhere [UserName ==. "SPJ" ] [UserAge -=. 1]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+---------+
--   |id   |name |age      |
--   +-----+-----+---------+
--   |1    |SPJ  |40 -&gt; 39 |
--   +-----+-----+---------+
--   |2    |Simon|41       |
--   +-----+-----+---------+
--   </pre>
(-=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Update v
infixr 3 -=.

-- | Assign a field by multiplication (<tt>*=</tt>).
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   multiplyAge :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   multiplyAge = updateWhere [UserName ==. "SPJ" ] [UserAge *=. 2]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+--------+
--   |id   |name |age     |
--   +-----+-----+--------+
--   |1    |SPJ  |40 -&gt; 80|
--   +-----+-----+--------+
--   |2    |Simon|41      |
--   +-----+-----+--------+
--   </pre>
(*=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Update v
infixr 3 *=.

-- | Assign a field by division (<tt>/=</tt>).
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   divideAge :: MonadIO m =&gt; ReaderT SqlBackend m ()
--   divideAge = updateWhere [UserName ==. "SPJ" ] [UserAge /=. 2]
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+---------+
--   |id   |name |age      |
--   +-----+-----+---------+
--   |1    |SPJ  |40 -&gt; 20 |
--   +-----+-----+---------+
--   |2    |Simon|41       |
--   +-----+-----+---------+
--   </pre>
(/=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Update v
infixr 3 /=.

-- | Check for equality.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectSPJ :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectSPJ = selectList [UserName ==. "SPJ" ] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |1    |SPJ  |40   |
--   +-----+-----+-----+
--   </pre>
(==.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Filter v
infix 4 ==.

-- | Non-equality check.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectSimon :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectSimon = selectList [UserName !=. "SPJ" ] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |2    |Simon|41   |
--   +-----+-----+-----+
--   </pre>
(!=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Filter v
infix 4 !=.

-- | Less-than check.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectLessAge :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectLessAge = selectList [UserAge &lt;. 41 ] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |1    |SPJ  |40   |
--   +-----+-----+-----+
--   </pre>
(<.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Filter v
infix 4 <.

-- | Greater-than check.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectGreaterAge :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectGreaterAge = selectList [UserAge &gt;. 40 ] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |2    |Simon|41   |
--   +-----+-----+-----+
--   </pre>
(>.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Filter v
infix 4 >.

-- | Less-than or equal check.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectLessEqualAge :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectLessEqualAge = selectList [UserAge &lt;=. 40 ] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |1    |SPJ  |40   |
--   +-----+-----+-----+
--   </pre>
(<=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Filter v
infix 4 <=.

-- | Greater-than or equal check.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectGreaterEqualAge :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectGreaterEqualAge = selectList [UserAge &gt;=. 41 ] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |2    |Simon|41   |
--   +-----+-----+-----+
--   </pre>
(>=.) :: forall v typ. PersistField typ => EntityField v typ -> typ -> Filter v
infix 4 >=.

-- | Check if value is in given list.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectUsers :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectUsers = selectList [UserAge &lt;-. [40, 41]] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |1    |SPJ  |40   |
--   +-----+-----+-----+
--   |2    |Simon|41   |
--   +-----+-----+-----+
--   </pre>
--   
--   <pre>
--   selectSPJ :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectSPJ = selectList [UserAge &lt;-. [40]] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |1    |SPJ  |40   |
--   +-----+-----+-----+
--   </pre>
(<-.) :: forall v typ. PersistField typ => EntityField v typ -> [typ] -> Filter v
infix 4 <-.

-- | Check if value is not in given list.
--   
--   <h3><b>Example usage</b></h3>
--   
--   <pre>
--   selectSimon :: MonadIO m =&gt; ReaderT SqlBackend m [Entity User]
--   selectSimon = selectList [UserAge /&lt;-. [40]] []
--   </pre>
--   
--   The above query when applied on <a>dataset-1</a>, will produce this:
--   
--   <pre>
--   +-----+-----+-----+
--   |id   |name |age  |
--   +-----+-----+-----+
--   |2    |Simon|41   |
--   +-----+-----+-----+
--   </pre>
(/<-.) :: forall v typ. PersistField typ => EntityField v typ -> [typ] -> Filter v
infix 4 /<-.

-- | The OR of two lists of filters. For example:
--   
--   <pre>
--   selectList
--       ([ PersonAge &gt;. 25
--        , PersonAge &lt;. 30 ] ||.
--        [ PersonIncome &gt;. 15000
--        , PersonIncome &lt;. 25000 ])
--       []
--   </pre>
--   
--   will filter records where a person's age is between 25 and 30
--   <i>or</i> a person's income is between (15000 and 25000).
--   
--   If you are looking for an <tt>(&amp;&amp;.)</tt> operator to do <tt>(A
--   AND B AND (C OR D))</tt> you can use the <tt>(++)</tt> operator
--   instead as there is no <tt>(&amp;&amp;.)</tt>. For example:
--   
--   <pre>
--   selectList
--       ([ PersonAge &gt;. 25
--        , PersonAge &lt;. 30 ] ++
--       ([PersonCategory ==. 1] ||.
--        [PersonCategory ==. 5]))
--       []
--   </pre>
--   
--   will filter records where a person's age is between 25 and 30
--   <i>and</i> (person's category is either 1 or 5).
(||.) :: forall v. [Filter v] -> [Filter v] -> [Filter v]
infixl 3 ||.

-- | Convert list of <a>PersistValue</a>s into textual representation of
--   JSON object. This is a type-constrained synonym for <a>toJsonText</a>.
listToJSON :: [PersistValue] -> Text

-- | Convert map (list of tuples) into textual representation of JSON
--   object. This is a type-constrained synonym for <a>toJsonText</a>.
mapToJSON :: [(Text, PersistValue)] -> Text

-- | A more general way to convert instances of <a>ToJSON</a> type class to
--   strict text <a>Text</a>.
toJsonText :: ToJSON j => j -> Text

-- | FIXME Add documentation to that.
getPersistMap :: PersistValue -> Either Text [(Text, PersistValue)]

-- | FIXME What's this exactly?
limitOffsetOrder :: PersistEntity val => [SelectOpt val] -> (Int, Int, [SelectOpt val])

module Database.Persist.Sql.Util
parseEntityValues :: PersistEntity record => EntityDef -> [PersistValue] -> Either Text (Entity record)
entityColumnNames :: EntityDef -> SqlBackend -> [Sql]
keyAndEntityColumnNames :: EntityDef -> SqlBackend -> [Sql]
entityColumnCount :: EntityDef -> Int
isIdField :: PersistEntity record => EntityField record typ -> Bool
hasCompositeKey :: EntityDef -> Bool
dbIdColumns :: SqlBackend -> EntityDef -> [Text]
dbIdColumnsEsc :: (DBName -> Text) -> EntityDef -> [Text]
dbColumns :: SqlBackend -> EntityDef -> [Text]

module Database.Persist.Sql

-- | Deprecated synonym for <tt>SqlBackend</tt>.

-- | <i>Deprecated: Please use SqlBackend instead</i>
type Connection = SqlBackend
data Column
Column :: !DBName -> !Bool -> !SqlType -> !(Maybe Text) -> !(Maybe DBName) -> !(Maybe Integer) -> !(Maybe (DBName, DBName)) -> Column
[cName] :: Column -> !DBName
[cNull] :: Column -> !Bool
[cSqlType] :: Column -> !SqlType
[cDefault] :: Column -> !(Maybe Text)
[cDefaultConstraintName] :: Column -> !(Maybe DBName)
[cMaxLen] :: Column -> !(Maybe Integer)
[cReference] :: Column -> !(Maybe (DBName, DBName))
data PersistentSqlException
StatementAlreadyFinalized :: Text -> PersistentSqlException
Couldn'tGetSQLConnection :: PersistentSqlException
type SqlPersistT = ReaderT SqlBackend

-- | <i>Deprecated: Please use SqlPersistT instead</i>
type SqlPersist = SqlPersistT
type SqlPersistM = SqlPersistT (NoLoggingT (ResourceT IO))
type Sql = Text
type CautiousMigration = [(Bool, Sql)]
type Migration = WriterT [Text] (WriterT CautiousMigration (ReaderT SqlBackend IO)) ()
type ConnectionPool = Pool SqlBackend

-- | A single column (see <tt>rawSql</tt>). Any <tt>PersistField</tt> may
--   be used here, including <a>PersistValue</a> (which does not do any
--   processing).
newtype Single a
Single :: a -> Single a
[unSingle] :: Single a -> a
data SqlBackend
SqlBackend :: (Text -> IO Statement) -> (EntityDef -> [PersistValue] -> InsertSqlResult) -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult) -> Maybe (EntityDef -> Text -> Text) -> IORef (Map Text Statement) -> IO () -> ([EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> ((Text -> IO Statement) -> IO ()) -> (DBName -> Text) -> Text -> Text -> ((Int, Int) -> Bool -> Text -> Text) -> LogFunc -> Maybe Int -> SqlBackend
[connPrepare] :: SqlBackend -> Text -> IO Statement

-- | table name, column names, id name, either 1 or 2 statements to run
[connInsertSql] :: SqlBackend -> EntityDef -> [PersistValue] -> InsertSqlResult

-- | SQL for inserting many rows and returning their primary keys, for
--   backends that support this functioanlity. If <a>Nothing</a>, rows will
--   be inserted one-at-a-time using <a>connInsertSql</a>.
[connInsertManySql] :: SqlBackend -> Maybe (EntityDef -> [[PersistValue]] -> InsertSqlResult)
[connUpsertSql] :: SqlBackend -> Maybe (EntityDef -> Text -> Text)
[connStmtMap] :: SqlBackend -> IORef (Map Text Statement)
[connClose] :: SqlBackend -> IO ()
[connMigrateSql] :: SqlBackend -> [EntityDef] -> (Text -> IO Statement) -> EntityDef -> IO (Either [Text] [(Bool, Text)])
[connBegin] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connCommit] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connRollback] :: SqlBackend -> (Text -> IO Statement) -> IO ()
[connEscapeName] :: SqlBackend -> DBName -> Text
[connNoLimit] :: SqlBackend -> Text
[connRDBMS] :: SqlBackend -> Text
[connLimitOffset] :: SqlBackend -> (Int, Int) -> Bool -> Text -> Text
[connLogFunc] :: SqlBackend -> LogFunc

-- | Some databases (probably only Sqlite) have a limit on how many
--   question-mark parameters may be used in a statement
[connMaxParams] :: SqlBackend -> Maybe Int

-- | An SQL backend which can only handle read queries
data SqlReadBackend

-- | An SQL backend which can handle read or write queries
data SqlWriteBackend
data Statement
Statement :: IO () -> IO () -> ([PersistValue] -> IO Int64) -> (forall m. MonadIO m => [PersistValue] -> Acquire (Source m [PersistValue])) -> Statement
[stmtFinalize] :: Statement -> IO ()
[stmtReset] :: Statement -> IO ()
[stmtExecute] :: Statement -> [PersistValue] -> IO Int64
[stmtQuery] :: Statement -> forall m. MonadIO m => [PersistValue] -> Acquire (Source m [PersistValue])
type LogFunc = Loc -> LogSource -> LogLevel -> LogStr -> IO ()
data InsertSqlResult
ISRSingle :: Text -> InsertSqlResult
ISRInsertGet :: Text -> Text -> InsertSqlResult
ISRManyKeys :: Text -> [PersistValue] -> InsertSqlResult

-- | Useful for running a read query against a backend with unknown
--   capabilities.
readToUnknown :: Monad m => ReaderT SqlReadBackend m a -> ReaderT SqlBackend m a

-- | Useful for running a read query against a backend with read and write
--   capabilities.
readToWrite :: Monad m => ReaderT SqlReadBackend m a -> ReaderT SqlWriteBackend m a

-- | Useful for running a write query against an untagged backend with
--   unknown capabilities.
writeToUnknown :: Monad m => ReaderT SqlWriteBackend m a -> ReaderT SqlBackend m a

-- | A constraint synonym which witnesses that a backend is SQL and can run
--   read queries.
type SqlBackendCanRead backend = (IsSqlBackend backend, PersistQueryRead backend, PersistStoreRead backend, PersistUniqueRead backend)

-- | A constraint synonym which witnesses that a backend is SQL and can run
--   read and write queries.
type SqlBackendCanWrite backend = (SqlBackendCanRead backend, PersistQueryWrite backend, PersistStoreWrite backend, PersistUniqueWrite backend)

-- | Like <tt>SqlPersistT</tt> but compatible with any SQL backend which
--   can handle read queries.
type SqlReadT m a = forall backend. (SqlBackendCanRead backend) => ReaderT backend m a

-- | Like <tt>SqlPersistT</tt> but compatible with any SQL backend which
--   can handle read and write queries.
type SqlWriteT m a = forall backend. (SqlBackendCanWrite backend) => ReaderT backend m a

-- | A backend which is a wrapper around <tt>SqlBackend</tt>.
type IsSqlBackend backend = (IsPersistBackend backend, BaseBackend backend ~ SqlBackend)

-- | Class for data types that may be retrived from a <tt>rawSql</tt>
--   query.
class RawSql a

-- | Number of columns that this data type needs and the list of
--   substitutions for <tt>SELECT</tt> placeholders <tt>??</tt>.
rawSqlCols :: RawSql a => (DBName -> Text) -> a -> (Int, [Text])

-- | A string telling the user why the column count is what it is.
rawSqlColCountReason :: RawSql a => a -> String

-- | Transform a row of the result into the data type.
rawSqlProcessRow :: RawSql a => [PersistValue] -> Either Text a
class PersistField a => PersistFieldSql a
sqlType :: PersistFieldSql a => Proxy a -> SqlType

-- | Get a connection from the pool, run the given action, and then return
--   the connection to the pool.
--   
--   Note: This function previously timed out after 2 seconds, but this
--   behavior was buggy and caused more problems than it solved. Since
--   version 2.1.2, it performs no timeout checks.
runSqlPool :: (MonadBaseControl IO m, IsSqlBackend backend) => ReaderT backend m a -> Pool backend -> m a

-- | Like <a>withResource</a>, but times out the operation if resource
--   allocation does not complete within the given timeout period.
--   
--   Since 2.0.0
withResourceTimeout :: forall a m b. (MonadBaseControl IO m) => Int -> Pool a -> (a -> m b) -> m (Maybe b)
runSqlConn :: (MonadBaseControl IO m, IsSqlBackend backend) => ReaderT backend m a -> backend -> m a
runSqlPersistM :: (IsSqlBackend backend) => ReaderT backend (NoLoggingT (ResourceT IO)) a -> backend -> IO a
runSqlPersistMPool :: (IsSqlBackend backend) => ReaderT backend (NoLoggingT (ResourceT IO)) a -> Pool backend -> IO a
liftSqlPersistMPool :: (MonadIO m, IsSqlBackend backend) => ReaderT backend (NoLoggingT (ResourceT IO)) a -> Pool backend -> m a
withSqlPool :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, IsSqlBackend backend) => (LogFunc -> IO backend) -> Int -> (Pool backend -> m a) -> m a
createSqlPool :: (MonadIO m, MonadLogger m, MonadBaseControl IO m, IsSqlBackend backend) => (LogFunc -> IO backend) -> Int -> m (Pool backend)
askLogFunc :: forall m. (MonadBaseControl IO m, MonadLogger m) => m LogFunc
withSqlConn :: (MonadIO m, MonadBaseControl IO m, MonadLogger m, IsSqlBackend backend) => (LogFunc -> IO backend) -> (backend -> m a) -> m a
close' :: (IsSqlBackend backend) => backend -> IO ()

-- | Given a <a>Migration</a>, this parses it and returns either a list of
--   errors associated with the migration or a list of migrations to do.
parseMigration :: MonadIO m => Migration -> ReaderT SqlBackend m (Either [Text] CautiousMigration)

-- | Like <a>parseMigration</a>, but instead of returning the value in an
--   <a>Either</a> value, it calls <a>error</a> on the error values.
parseMigration' :: MonadIO m => Migration -> ReaderT SqlBackend m (CautiousMigration)

-- | Prints a migration.
printMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Convert a <a>Migration</a> to a list of <a>Text</a> values
--   corresponding to their <a>Sql</a> statements.
showMigration :: MonadIO m => Migration -> ReaderT SqlBackend m [Text]

-- | Return all of the <a>Sql</a> values associated with the given
--   migration. Calls <a>error</a> if there's a parse error on any
--   migration.
getMigration :: MonadIO m => Migration -> ReaderT SqlBackend m [Sql]

-- | Runs a migration. If the migration fails to parse or if any of the
--   migrations are unsafe, then this calls <a>error</a> to halt the
--   program.
runMigration :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Same as <a>runMigration</a>, but returns a list of the SQL commands
--   executed instead of printing them to stderr.
runMigrationSilent :: (MonadBaseControl IO m, MonadIO m) => Migration -> ReaderT SqlBackend m [Text]

-- | Like <a>runMigration</a>, but this will perform the unsafe database
--   migrations instead of erroring out.
runMigrationUnsafe :: MonadIO m => Migration -> ReaderT SqlBackend m ()

-- | Given a list of old entity definitions and a new <a>EntityDef</a> in
--   <tt>val</tt>, this creates a <a>Migration</a> to update the old list
--   of definitions with the new one.
migrate :: [EntityDef] -> EntityDef -> Migration
withRawQuery :: MonadIO m => Text -> [PersistValue] -> Sink [PersistValue] IO a -> ReaderT SqlBackend m a
toSqlKey :: ToBackendKey SqlBackend record => Int64 -> Key record
fromSqlKey :: ToBackendKey SqlBackend record => Key record -> Int64

-- | get the SQL string for the field that an EntityField represents Useful
--   for raw SQL queries
--   
--   Your backend may provide a more convenient fieldName function which
--   does not operate in a Monad
getFieldName :: forall record typ m backend. (PersistEntity record, PersistEntityBackend record ~ SqlBackend, IsSqlBackend backend, Monad m) => EntityField record typ -> ReaderT backend m Text

-- | get the SQL string for the table that a PeristEntity represents Useful
--   for raw SQL queries
--   
--   Your backend may provide a more convenient tableName function which
--   does not operate in a Monad
getTableName :: forall record m backend. (PersistEntity record, PersistEntityBackend record ~ SqlBackend, IsSqlBackend backend, Monad m) => record -> ReaderT backend m Text

-- | useful for a backend to implement tableName by adding escaping
tableDBName :: (PersistEntity record) => record -> DBName

-- | useful for a backend to implement fieldName by adding escaping
fieldDBName :: forall record typ. (PersistEntity record) => EntityField record typ -> DBName
rawQuery :: (MonadResource m, MonadReader env m, HasPersistBackend env, BaseBackend env ~ SqlBackend) => Text -> [PersistValue] -> Source m [PersistValue]
rawQueryRes :: (MonadIO m1, MonadIO m2, IsSqlBackend env) => Text -> [PersistValue] -> ReaderT env m1 (Acquire (Source m2 [PersistValue]))

-- | Execute a raw SQL statement
rawExecute :: MonadIO m => Text -> [PersistValue] -> ReaderT SqlBackend m ()

-- | Execute a raw SQL statement and return the number of rows it has
--   modified.
rawExecuteCount :: (MonadIO m, IsSqlBackend backend) => Text -> [PersistValue] -> ReaderT backend m Int64

-- | Execute a raw SQL statement and return its results as a list.
--   
--   If you're using <a>Entity</a><tt>s</tt> (which is quite likely), then
--   you <i>must</i> use entity selection placeholders (double question
--   mark, <tt>??</tt>). These <tt>??</tt> placeholders are then replaced
--   for the names of the columns that we need for your entities. You'll
--   receive an error if you don't use the placeholders. Please see the
--   <a>Entity</a><tt>s</tt> documentation for more details.
--   
--   You may put value placeholders (question marks, <tt>?</tt>) in your
--   SQL query. These placeholders are then replaced by the values you pass
--   on the second parameter, already correctly escaped. You may want to
--   use <a>toPersistValue</a> to help you constructing the placeholder
--   values.
--   
--   Since you're giving a raw SQL statement, you don't get any guarantees
--   regarding safety. If <a>rawSql</a> is not able to parse the results of
--   your query back, then an exception is raised. However, most common
--   problems are mitigated by using the entity selection placeholder
--   <tt>??</tt>, and you shouldn't see any error at all if you're not
--   using <a>Single</a>.
--   
--   Some example of <a>rawSql</a> based on this schema:
--   
--   <pre>
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
--   Person
--       name String
--       age Int Maybe
--       deriving Show
--   BlogPost
--       title String
--       authorId PersonId
--       deriving Show
--   |]
--   </pre>
--   
--   Examples based on the above schema:
--   
--   <pre>
--   getPerson :: MonadIO m =&gt; ReaderT SqlBackend m [Entity Person]
--   getPerson = rawSql "select ?? from person where name=?" [PersistText "john"]
--   
--   getAge :: MonadIO m =&gt; ReaderT SqlBackend m [Single Int]
--   getAge = rawSql "select person.age from person where name=?" [PersistText "john"]
--   
--   getAgeName :: MonadIO m =&gt; ReaderT SqlBackend m [(Single Int, Single Text)]
--   getAgeName = rawSql "select person.age, person.name from person where name=?" [PersistText "john"]
--   
--   getPersonBlog :: MonadIO m =&gt; ReaderT SqlBackend m [(Entity Person, Entity BlogPost)]
--   getPersonBlog = rawSql "select ??,?? from person,blog_post where person.id = blog_post.author_id" []
--   </pre>
--   
--   Minimal working program for PostgreSQL backend based on the above
--   concepts:
--   
--   <pre>
--   {-# LANGUAGE EmptyDataDecls             #-}
--   {-# LANGUAGE FlexibleContexts           #-}
--   {-# LANGUAGE GADTs                      #-}
--   {-# LANGUAGE GeneralizedNewtypeDeriving #-}
--   {-# LANGUAGE MultiParamTypeClasses      #-}
--   {-# LANGUAGE OverloadedStrings          #-}
--   {-# LANGUAGE QuasiQuotes                #-}
--   {-# LANGUAGE TemplateHaskell            #-}
--   {-# LANGUAGE TypeFamilies               #-}
--   
--   import           Control.Monad.IO.Class  (liftIO)
--   import           Control.Monad.Logger    (runStderrLoggingT)
--   import           Database.Persist
--   import           Control.Monad.Reader
--   import           Data.Text
--   import           Database.Persist.Sql
--   import           Database.Persist.Postgresql
--   import           Database.Persist.TH
--   
--   share [mkPersist sqlSettings, mkMigrate "migrateAll"] [persistLowerCase|
--   Person
--       name String
--       age Int Maybe
--       deriving Show
--   |]
--   
--   conn = "host=localhost dbname=new_db user=postgres password=postgres port=5432"
--   
--   getPerson :: MonadIO m =&gt; ReaderT SqlBackend m [Entity Person]
--   getPerson = rawSql "select ?? from person where name=?" [PersistText "sibi"]
--   
--   liftSqlPersistMPool y x = liftIO (runSqlPersistMPool y x)
--   
--   main :: IO ()
--   main = runStderrLoggingT $ withPostgresqlPool conn 10 $ liftSqlPersistMPool $ do
--            runMigration migrateAll
--            xs &lt;- getPerson
--            liftIO (print xs)
--   </pre>
rawSql :: (RawSql a, MonadIO m) => Text -> [PersistValue] -> ReaderT SqlBackend m [a]

-- | Same as <a>deleteWhere</a>, but returns the number of rows affected.
--   
--   Since 1.1.5
deleteWhereCount :: (PersistEntity val, MonadIO m, PersistEntityBackend val ~ SqlBackend, IsSqlBackend backend) => [Filter val] -> ReaderT backend m Int64

-- | Same as <a>updateWhere</a>, but returns the number of rows affected.
--   
--   Since 1.1.5
updateWhereCount :: (PersistEntity val, MonadIO m, SqlBackend ~ PersistEntityBackend val, IsSqlBackend backend) => [Filter val] -> [Update val] -> ReaderT backend m Int64

-- | Commit the current transaction and begin a new one.
--   
--   Since 1.2.0
transactionSave :: MonadIO m => ReaderT SqlBackend m ()

-- | Roll back the current transaction and begin a new one.
--   
--   Since 1.2.0
transactionUndo :: MonadIO m => ReaderT SqlBackend m ()
getStmtConn :: SqlBackend -> Text -> IO Statement

-- | Create the list of columns for the given entity.
mkColumns :: [EntityDef] -> EntityDef -> ([Column], [UniqueDef], [ForeignDef])
defaultAttribute :: [Attr] -> Maybe Text

-- | Generates sql for limit and offset for postgres, sqlite and mysql.
decorateSQLWithLimitOffset :: Text -> (Int, Int) -> Bool -> Text -> Text
