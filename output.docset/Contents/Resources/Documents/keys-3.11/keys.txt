-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Keyed functors and containers
--   
--   Keyed functors and containers
@package keys
@version 3.11

module Data.Key
class Functor f => Keyed f
mapWithKey :: Keyed f => (Key f -> a -> b) -> f a -> f b
(<#$>) :: Keyed f => (Key f -> a -> b) -> f a -> f b
infixl 4 <#$>
keyed :: Keyed f => f a -> f (Key f, a)
class Functor f => Zip f where zipWith f a b = uncurry f <$> zip a b zip = zipWith (,) zap = zipWith id
zipWith :: Zip f => (a -> b -> c) -> f a -> f b -> f c
zip :: Zip f => f a -> f b -> f (a, b)
zap :: Zip f => f (a -> b) -> f a -> f b
class (Keyed f, Zip f) => ZipWithKey f where zipWithKey f = zap . mapWithKey f zapWithKey = zipWithKey (\ k f -> f k)
zipWithKey :: ZipWithKey f => (Key f -> a -> b -> c) -> f a -> f b -> f c
zapWithKey :: ZipWithKey f => f (Key f -> a -> b) -> f a -> f b
class Lookup f => Indexable f
index :: Indexable f => f a -> Key f -> a
(!) :: Indexable f => f a -> Key f -> a
class Lookup f
lookup :: Lookup f => Key f -> f a -> Maybe a
lookupDefault :: Indexable f => Key f -> f a -> Maybe a
class Functor f => Adjustable f where replace k v = adjust (const v) k
adjust :: Adjustable f => (a -> a) -> Key f -> f a -> f a
replace :: Adjustable f => Key f -> a -> f a -> f a
class Foldable t => FoldableWithKey t where toKeyedList = foldrWithKey (\ k v t -> (k, v) : t) [] foldMapWithKey f = foldrWithKey (\ k v -> mappend (f k v)) mempty foldrWithKey f z t = appEndo (foldMapWithKey (\ k v -> Endo (f k v)) t) z foldlWithKey f z t = appEndo (getDual (foldMapWithKey (\ k a -> Dual (Endo (\ b -> f b k a))) t)) z
toKeyedList :: FoldableWithKey t => t a -> [(Key t, a)]
foldMapWithKey :: (FoldableWithKey t, Monoid m) => (Key t -> a -> m) -> t a -> m
foldrWithKey :: FoldableWithKey t => (Key t -> a -> b -> b) -> b -> t a -> b
foldlWithKey :: FoldableWithKey t => (b -> Key t -> a -> b) -> b -> t a -> b
foldrWithKey' :: FoldableWithKey t => (Key t -> a -> b -> b) -> b -> t a -> b
foldlWithKey' :: FoldableWithKey t => (b -> Key t -> a -> b) -> b -> t a -> b
foldrWithKeyM :: (FoldableWithKey t, Monad m) => (Key t -> a -> b -> m b) -> b -> t a -> m b
foldlWithKeyM :: (FoldableWithKey t, Monad m) => (b -> Key t -> a -> m b) -> b -> t a -> m b
traverseWithKey_ :: (FoldableWithKey t, Applicative f) => (Key t -> a -> f b) -> t a -> f ()
forWithKey_ :: (FoldableWithKey t, Applicative f) => t a -> (Key t -> a -> f b) -> f ()
mapWithKeyM_ :: (FoldableWithKey t, Monad m) => (Key t -> a -> m b) -> t a -> m ()
forWithKeyM_ :: (FoldableWithKey t, Monad m) => t a -> (Key t -> a -> m b) -> m ()
concatMapWithKey :: FoldableWithKey t => (Key t -> a -> [b]) -> t a -> [b]
anyWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Bool
allWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Bool
findWithKey :: FoldableWithKey t => (Key t -> a -> Bool) -> t a -> Maybe a
class (Foldable1 t, FoldableWithKey t) => FoldableWithKey1 t
foldMapWithKey1 :: (FoldableWithKey1 t, Semigroup m) => (Key t -> a -> m) -> t a -> m
traverseWithKey1_ :: (FoldableWithKey1 t, Apply f) => (Key t -> a -> f b) -> t a -> f ()
forWithKey1_ :: (FoldableWithKey1 t, Apply f) => t a -> (Key t -> a -> f b) -> f ()
foldMapWithKeyDefault1 :: (FoldableWithKey1 t, Monoid m) => (Key t -> a -> m) -> t a -> m
class (Keyed t, FoldableWithKey t, Traversable t) => TraversableWithKey t where mapWithKeyM f = unwrapMonad . traverseWithKey (fmap WrapMonad . f)
traverseWithKey :: (TraversableWithKey t, Applicative f) => (Key t -> a -> f b) -> t a -> f (t b)
mapWithKeyM :: (TraversableWithKey t, Monad m) => (Key t -> a -> m b) -> t a -> m (t b)
forWithKey :: (TraversableWithKey t, Applicative f) => t a -> (Key t -> a -> f b) -> f (t b)
forWithKeyM :: (TraversableWithKey t, Monad m) => t a -> (Key t -> a -> m b) -> m (t b)

-- | The <a>mapAccumWithKeyL</a> function behaves like a combination of
--   <a>mapWithKey</a> and <a>foldlWithKey</a>; it applies a function to
--   each element of a structure, passing an accumulating parameter from
--   left to right, and returning a final value of this accumulator
--   together with the new structure.
mapAccumWithKeyL :: TraversableWithKey t => (Key t -> a -> b -> (a, c)) -> a -> t b -> (a, t c)

-- | The <a>mapAccumWithKeyR</a> function behaves like a combination of
--   <a>mapWithKey</a> and <a>foldrWithKey</a>; it applies a function to
--   each element of a structure, passing an accumulating parameter from
--   right to left, and returning a final value of this accumulator
--   together with the new structure.
mapAccumWithKeyR :: TraversableWithKey t => (Key t -> a -> b -> (a, c)) -> a -> t b -> (a, t c)
mapWithKeyDefault :: TraversableWithKey t => (Key t -> a -> b) -> t a -> t b

-- | This function may be used as a value for <a>foldMapWithKey</a> in a
--   <a>FoldableWithKey</a> instance.
foldMapWithKeyDefault :: (TraversableWithKey t, Monoid m) => (Key t -> a -> m) -> t a -> m
class (Traversable1 t, FoldableWithKey1 t, TraversableWithKey t) => TraversableWithKey1 t
traverseWithKey1 :: (TraversableWithKey1 t, Apply f) => (Key t -> a -> f b) -> t a -> f (t b)
foldMapWithKey1Default :: (TraversableWithKey1 t, Semigroup m) => (Key t -> a -> m) -> t a -> m
instance Data.Key.Keyed f => Data.Key.Keyed (Control.Monad.Free.Free f)
instance Data.Key.Keyed f => Data.Key.Keyed (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Keyed Data.Tree.Tree
instance Data.Key.Zip f => Data.Key.Zip (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Zip Data.Tree.Tree
instance Data.Key.ZipWithKey f => Data.Key.ZipWithKey (Control.Comonad.Cofree.Cofree f)
instance Data.Key.ZipWithKey Data.Tree.Tree
instance Data.Key.Indexable f => Data.Key.Indexable (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Indexable Data.Tree.Tree
instance Data.Key.Lookup f => Data.Key.Lookup (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Lookup Data.Tree.Tree
instance Data.Key.Lookup f => Data.Key.Lookup (Control.Monad.Free.Free f)
instance Data.Key.Adjustable f => Data.Key.Adjustable (Control.Monad.Free.Free f)
instance Data.Key.Adjustable f => Data.Key.Adjustable (Control.Comonad.Cofree.Cofree f)
instance Data.Key.Adjustable Data.Tree.Tree
instance Data.Key.FoldableWithKey f => Data.Key.FoldableWithKey (Control.Monad.Free.Free f)
instance Data.Key.FoldableWithKey f => Data.Key.FoldableWithKey (Control.Comonad.Cofree.Cofree f)
instance Data.Key.FoldableWithKey Data.Tree.Tree
instance Data.Key.FoldableWithKey1 f => Data.Key.FoldableWithKey1 (Control.Comonad.Cofree.Cofree f)
instance Data.Key.FoldableWithKey1 Data.Tree.Tree
instance Data.Key.FoldableWithKey1 f => Data.Key.FoldableWithKey1 (Control.Monad.Free.Free f)
instance Data.Functor.Bind.Class.Apply f => Data.Semigroup.Semigroup (Data.Key.Act f a)
instance GHC.Base.Functor f => GHC.Base.Functor (Data.Key.Act f)
instance Data.Key.TraversableWithKey f => Data.Key.TraversableWithKey (Control.Comonad.Cofree.Cofree f)
instance Data.Key.TraversableWithKey Data.Tree.Tree
instance Data.Key.TraversableWithKey f => Data.Key.TraversableWithKey (Control.Monad.Free.Free f)
instance GHC.Base.Functor (Data.Key.StateL s)
instance GHC.Base.Applicative (Data.Key.StateL s)
instance GHC.Base.Functor (Data.Key.StateR s)
instance GHC.Base.Applicative (Data.Key.StateR s)
instance Data.Key.TraversableWithKey1 f => Data.Key.TraversableWithKey1 (Control.Comonad.Cofree.Cofree f)
instance Data.Key.TraversableWithKey1 Data.Tree.Tree
instance Data.Key.TraversableWithKey1 f => Data.Key.TraversableWithKey1 (Control.Monad.Free.Free f)
instance Data.Key.Indexable Data.Functor.Identity.Identity
instance Data.Key.Lookup Data.Functor.Identity.Identity
instance Data.Key.Adjustable Data.Functor.Identity.Identity
instance Data.Key.Zip Data.Functor.Identity.Identity
instance Data.Key.ZipWithKey Data.Functor.Identity.Identity
instance Data.Key.Keyed Data.Functor.Identity.Identity
instance Data.Key.FoldableWithKey Data.Functor.Identity.Identity
instance Data.Key.FoldableWithKey1 Data.Functor.Identity.Identity
instance Data.Key.TraversableWithKey Data.Functor.Identity.Identity
instance Data.Key.TraversableWithKey1 Data.Functor.Identity.Identity
instance Data.Key.Indexable m => Data.Key.Indexable (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Lookup m => Data.Key.Lookup (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Zip m => Data.Key.Zip (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.ZipWithKey m => Data.Key.ZipWithKey (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Keyed m => Data.Key.Keyed (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.FoldableWithKey m => Data.Key.FoldableWithKey (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.FoldableWithKey1 m => Data.Key.FoldableWithKey1 (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.TraversableWithKey m => Data.Key.TraversableWithKey (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.TraversableWithKey1 m => Data.Key.TraversableWithKey1 (Control.Monad.Trans.Identity.IdentityT m)
instance Data.Key.Keyed ((->) a)
instance Data.Key.Zip ((->) a)
instance Data.Key.ZipWithKey ((->) a)
instance Data.Key.Indexable ((->) a)
instance Data.Key.Lookup ((->) a)
instance Data.Key.Zip m => Data.Key.Zip (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.ZipWithKey m => Data.Key.ZipWithKey (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Keyed m => Data.Key.Keyed (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Indexable m => Data.Key.Indexable (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Lookup m => Data.Key.Lookup (Control.Monad.Trans.Reader.ReaderT e m)
instance Data.Key.Zip w => Data.Key.Zip (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.ZipWithKey w => Data.Key.ZipWithKey (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Keyed w => Data.Key.Keyed (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Indexable w => Data.Key.Indexable (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Lookup w => Data.Key.Lookup (Control.Comonad.Trans.Traced.TracedT s w)
instance Data.Key.Zip Data.IntMap.Base.IntMap
instance Data.Key.ZipWithKey Data.IntMap.Base.IntMap
instance Data.Key.Keyed Data.IntMap.Base.IntMap
instance Data.Key.FoldableWithKey Data.IntMap.Base.IntMap
instance Data.Key.TraversableWithKey Data.IntMap.Base.IntMap
instance Data.Key.Indexable Data.IntMap.Base.IntMap
instance Data.Key.Lookup Data.IntMap.Base.IntMap
instance Data.Key.Adjustable Data.IntMap.Base.IntMap
instance (Data.Key.Zip f, Data.Key.Zip g) => Data.Key.Zip (Data.Functor.Compose.Compose f g)
instance (Data.Key.ZipWithKey f, Data.Key.ZipWithKey g) => Data.Key.ZipWithKey (Data.Functor.Compose.Compose f g)
instance (Data.Key.Keyed f, Data.Key.Keyed g) => Data.Key.Keyed (Data.Functor.Compose.Compose f g)
instance (Data.Key.Indexable f, Data.Key.Indexable g) => Data.Key.Indexable (Data.Functor.Compose.Compose f g)
instance (Data.Key.Lookup f, Data.Key.Lookup g) => Data.Key.Lookup (Data.Functor.Compose.Compose f g)
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey m) => Data.Key.FoldableWithKey (Data.Functor.Compose.Compose f m)
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 m) => Data.Key.FoldableWithKey1 (Data.Functor.Compose.Compose f m)
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey m) => Data.Key.TraversableWithKey (Data.Functor.Compose.Compose f m)
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 m) => Data.Key.TraversableWithKey1 (Data.Functor.Compose.Compose f m)
instance Data.Key.Zip []
instance Data.Key.ZipWithKey []
instance Data.Key.Keyed []
instance Data.Key.FoldableWithKey []
instance Data.Key.TraversableWithKey []
instance Data.Key.Indexable []
instance Data.Key.Lookup []
instance Data.Key.Adjustable []
instance Data.Key.Zip Data.List.NonEmpty.NonEmpty
instance Data.Key.ZipWithKey Data.List.NonEmpty.NonEmpty
instance Data.Key.Keyed Data.List.NonEmpty.NonEmpty
instance Data.Key.FoldableWithKey Data.List.NonEmpty.NonEmpty
instance Data.Key.TraversableWithKey Data.List.NonEmpty.NonEmpty
instance Data.Key.Indexable Data.List.NonEmpty.NonEmpty
instance Data.Key.Lookup Data.List.NonEmpty.NonEmpty
instance Data.Key.Adjustable Data.List.NonEmpty.NonEmpty
instance Data.Key.FoldableWithKey1 Data.List.NonEmpty.NonEmpty
instance Data.Key.TraversableWithKey1 Data.List.NonEmpty.NonEmpty
instance Data.Key.Indexable Data.Sequence.Seq
instance Data.Key.Lookup Data.Sequence.Seq
instance Data.Key.Zip Data.Sequence.Seq
instance Data.Key.ZipWithKey Data.Sequence.Seq
instance Data.Key.Adjustable Data.Sequence.Seq
instance Data.Key.Keyed Data.Sequence.Seq
instance Data.Key.FoldableWithKey Data.Sequence.Seq
instance Data.Key.TraversableWithKey Data.Sequence.Seq
instance GHC.Classes.Ord k => Data.Key.Zip (Data.Map.Base.Map k)
instance GHC.Classes.Ord k => Data.Key.ZipWithKey (Data.Map.Base.Map k)
instance Data.Key.Keyed (Data.Map.Base.Map k)
instance GHC.Classes.Ord k => Data.Key.Indexable (Data.Map.Base.Map k)
instance GHC.Classes.Ord k => Data.Key.Lookup (Data.Map.Base.Map k)
instance Data.Key.FoldableWithKey (Data.Map.Base.Map k)
instance Data.Key.TraversableWithKey (Data.Map.Base.Map k)
instance GHC.Classes.Ord k => Data.Key.Adjustable (Data.Map.Base.Map k)
instance GHC.Arr.Ix i => Data.Key.Keyed (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Data.Key.Indexable (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Data.Key.Lookup (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Data.Key.FoldableWithKey (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Data.Key.TraversableWithKey (GHC.Arr.Array i)
instance GHC.Arr.Ix i => Data.Key.Adjustable (GHC.Arr.Array i)
instance (Data.Key.Indexable f, Data.Key.Indexable g) => Data.Key.Indexable (Data.Functor.Sum.Sum f g)
instance (Data.Key.Lookup f, Data.Key.Lookup g) => Data.Key.Lookup (Data.Functor.Sum.Sum f g)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (Data.Functor.Sum.Sum f g)
instance (Data.Key.Keyed f, Data.Key.Keyed g) => Data.Key.Keyed (Data.Functor.Product.Product f g)
instance (Data.Key.Indexable f, Data.Key.Indexable g) => Data.Key.Indexable (Data.Functor.Product.Product f g)
instance (Data.Key.Lookup f, Data.Key.Lookup g) => Data.Key.Lookup (Data.Functor.Product.Product f g)
instance (Data.Key.Zip f, Data.Key.Zip g) => Data.Key.Zip (Data.Functor.Product.Product f g)
instance (Data.Key.ZipWithKey f, Data.Key.ZipWithKey g) => Data.Key.ZipWithKey (Data.Functor.Product.Product f g)
instance (Data.Key.FoldableWithKey f, Data.Key.FoldableWithKey g) => Data.Key.FoldableWithKey (Data.Functor.Product.Product f g)
instance (Data.Key.FoldableWithKey1 f, Data.Key.FoldableWithKey1 g) => Data.Key.FoldableWithKey1 (Data.Functor.Product.Product f g)
instance (Data.Key.TraversableWithKey f, Data.Key.TraversableWithKey g) => Data.Key.TraversableWithKey (Data.Functor.Product.Product f g)
instance (Data.Key.TraversableWithKey1 f, Data.Key.TraversableWithKey1 g) => Data.Key.TraversableWithKey1 (Data.Functor.Product.Product f g)
instance (Data.Key.Adjustable f, Data.Key.Adjustable g) => Data.Key.Adjustable (Data.Functor.Product.Product f g)
instance Data.Key.Keyed ((,) k)
instance Data.Key.FoldableWithKey ((,) k)
instance Data.Key.FoldableWithKey1 ((,) k)
instance Data.Key.TraversableWithKey ((,) k)
instance Data.Key.TraversableWithKey1 ((,) k)
instance Data.Key.Keyed (Data.HashMap.Base.HashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.Indexable (Data.HashMap.Base.HashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.Lookup (Data.HashMap.Base.HashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.Zip (Data.HashMap.Base.HashMap k)
instance (GHC.Classes.Eq k, Data.Hashable.Class.Hashable k) => Data.Key.ZipWithKey (Data.HashMap.Base.HashMap k)
instance Data.Key.FoldableWithKey (Data.HashMap.Base.HashMap k)
instance Data.Key.TraversableWithKey (Data.HashMap.Base.HashMap k)
instance Data.Key.Keyed GHC.Base.Maybe
instance Data.Key.Indexable GHC.Base.Maybe
instance Data.Key.Lookup GHC.Base.Maybe
instance Data.Key.Zip GHC.Base.Maybe
instance Data.Key.ZipWithKey GHC.Base.Maybe
instance Data.Key.FoldableWithKey GHC.Base.Maybe
instance Data.Key.TraversableWithKey GHC.Base.Maybe
